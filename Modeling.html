

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modeling &mdash; x-psi 3.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/nbsphinx-code-cells.css?v=2aa19091" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=796a81b5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Instrument synergy" href="Instrument_synergy.html" />
    <link rel="prev" title="X-PSI 101 - For Beginners" href="XPSI_101.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            x-psi
              <img src="_static/xpsilogo_small.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQs and common problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="applications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="HPC_systems.html">HPC systems</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="code_of_conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">Future</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Team and acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="citation.html">Citation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Start_here.html">Start here</a></li>
<li class="toctree-l1"><a class="reference internal" href="XPSI_101.html">X-PSI 101 - For Beginners</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Likelihood">Likelihood</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#The-parameter-space">The parameter space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Interlude:-fast-and-slow-parameters">Interlude: fast and slow parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Data">Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Instrument">Instrument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Signal">Signal</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Constructing-a-star">Constructing a star</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#The-ambient-spacetime">The ambient spacetime</a></li>
<li class="toctree-l4"><a class="reference internal" href="#The-photosphere-and-its-constituent-regions">The photosphere and its constituent regions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Star">Star</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#A-callable-likelihood-object">A callable likelihood object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Inspecting-functionality">Inspecting functionality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Prior">Prior</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Custom-subclass">Custom subclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Density-and-support-checking">Density and support checking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Sampling-interface">Sampling interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#MultiNest">MultiNest</a></li>
<li class="toctree-l3"><a class="reference internal" href="#UltraNest">UltraNest</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Ensemble-MCMC">Ensemble MCMC</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Synthesis">Synthesis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Background">Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Data-format">Data format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Custom-method">Custom method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Synthesise">Synthesise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Instrument_synergy.html">Instrument synergy</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hot_region_complexity.html">Hot region complexity</a></li>
<li class="toctree-l1"><a class="reference internal" href="Global_surface_emission.html">Global surface emission</a></li>
<li class="toctree-l1"><a class="reference internal" href="Surface_radiation_field_tools.html">Surface radiation field tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modeling_without_statistics.html">Modeling (without statistics)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Polarization.html">Polarization</a></li>
<li class="toctree-l1"><a class="reference internal" href="Post-processing.html">Post-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="Emitting_patterns_2Dprojection.html">Emitting Patterns 2D Projection</a></li>
<li class="toctree-l1"><a class="reference internal" href="Accretion_disk.html">Accretion disk</a></li>
<li class="toctree-l1"><a class="reference internal" href="Multiple_imaging.html">Multiple imaging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Importance_sampling.html">Importance Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Module_generator_tutorial.html">Module generator tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_script_and_modules.html">Example script and modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_job.html">Example job</a></li>
<li class="toctree-l1"><a class="reference internal" href="x_p_sbi.html">Posterior Inference using SBI</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="likelihood_api.html">Likelihood API</a></li>
<li class="toctree-l1"><a class="reference internal" href="extension_modules.html">Extension modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="posterior_api.html">Posterior API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">x-psi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Modeling</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Modeling.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Modeling">
<h1>Modeling<a class="headerlink" href="#Modeling" title="Link to this heading"></a></h1>
<p>To run this tutorial, all data files should be available in in the directory <code class="docutils literal notranslate"><span class="pre">examples/examples_modeling_tutorial/model_data/</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline

import os
import numpy as np
import math
import time

from matplotlib import pyplot as plt
from matplotlib import rcParams
from matplotlib.ticker import MultipleLocator, AutoLocator, AutoMinorLocator
from matplotlib import gridspec
from matplotlib import cm

rcParams[&#39;text.usetex&#39;] = False
rcParams[&#39;font.size&#39;] = 14.0

import xpsi

from xpsi.global_imports import _c, _G, _dpr, gravradius, _csq, _km, _2pi
from xpsi.utilities import PlottingLibrary as XpsiPlot
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
/=============================================\
| X-PSI: X-ray Pulse Simulation and Inference |
|---------------------------------------------|
|                Version: 3.0.6               |
|---------------------------------------------|
|      https://xpsi-group.github.io/xpsi      |
\=============================================/

Check your emcee installation.
Check your installation of emcee if using the EnsembleSampler
Imported PyMultiNest.
Imported UltraNest.
Warning: Cannot import torch and test SBI_wrapper.
Imported GetDist version: 1.5.3
Imported nestcheck version: 0.2.1
</pre></div></div>
</div>
<p>Let’s build a generative model for the data; first we build a <em>callable</em> object for likelihood evaluation, and then we build a <em>callable</em> object for prior-density evaluation.</p>
<p>En route, we will explain why various software design choices were made during development. In some cases the conventions defined are not necessarily important for future development and indeed we expect them to be redesigned.</p>
<section id="Likelihood">
<h2>Likelihood<a class="headerlink" href="#Likelihood" title="Link to this heading"></a></h2>
<p>If you have not yet read the <a class="reference internal" href="overview.html"><span class="doc">likelihood overview</span></a>, it is advisable to do so now, or refer to a paper such as <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...887L..21R/abstract">Riley et al. (2019)</a>.</p>
<section id="The-parameter-space">
<h3>The parameter space<a class="headerlink" href="#The-parameter-space" title="Link to this heading"></a></h3>
<p>In order to implement an X-PSI likelihood function it is first necessary to define an underlying model parameter space. In general the parameter space is <span class="math notranslate nohighlight">\(\mathbb{R}^{d}\)</span>, where <span class="math notranslate nohighlight">\(d\in\mathbb{N}\)</span> is the total number of free model parameters. Each free parameter is an instance of the <a class="reference internal" href="parameter.html#xpsi.Parameter.Parameter"><span class="std std-ref">Parameter</span></a> class. We also support fixed (or frozen) variables and <em>derived</em> variables that are deterministic functions of other variables (notably, free
parameters).</p>
<p>In X-PSI we build upon a base class representing a <a class="reference internal" href="parameterSubspace.html#xpsi.ParameterSubspace.ParameterSubspace"><span class="std std-ref">ParameterSubspace</span></a>. To construct an X-PSI model a set of objects are defined which <em>derive</em> from this parameter subspace, and it is the <em>union</em> of these objects that forms both the global model parameter space, and a set of methods and attributes for evaluation of a parametrised sampling distribution of the data at the vector <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>, conditional on a vector of model
parameter values.</p>
<p>Our aim is to construct a <em>callable</em> <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object to feed as a <em>callback</em> function to a posterior sampler and a posterior integrator. We illustrate this object in the diagram below; all nodes in the diagram below represent objects (instances of some class). In some cases there are multiple instances of a particular class, in other cases there is only a single instance of a particular class. Moreover, a subset of these classes inherit from (subclass)
<a class="reference internal" href="parameterSubspace.html#xpsi.ParameterSubspace.ParameterSubspace"><span class="std std-ref">ParameterSubspace</span></a>, because instances of these classes are objects with a parameter subspace and a collection of methods with instructions for handling parameter vectors in that subspace (methods and attributes to, e.g., calculate and store some <em>derived</em> quantities of the underlying theory/model respectively for likelihood evaluation).</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from IPython.display import Image
Image(&quot;./_static/oop_modelling_diagram_v1.png&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_9_0.png" src="_images/Modeling_9_0.png" />
</div>
</div>
<p>The arrows in the diagram denote an object that is stored as an attribute of another encapsulating (a reference to) another object. When a call is processed to evaluate the likelihood given a vector of model parameter values, encapsulating objects get attributes (magically including method calls) of the wrapped objects. The likelihood call results in a cascade of attribute lookups by objects higher in the hierarchy to those lower in the hierarchy. An arguably powerful aspect of the
implementation is the merging of parameter subspaces when references to two or more subspaces are encapsulated with an object higher in the hierarchy. This permits parameters to be accessed via Python container <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> and <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> magic on any object (deriving from <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code>) that encapsulates references to them.</p>
<p>We will now briefly describe the purpose of each object above which is encapsulated by the callable <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object (<code class="docutils literal notranslate"><span class="pre">Likelihood</span></code> in the diagram to denote the name of the class of which it is an instance). Note the use of the term <em>abstract base class</em>, which means that a user is required to subclass, and thereby provide a concrete implementation of some functionality specific to their model. Some source code classes are concrete classes that can be instantiated directly.</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">Star</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class. It represents the model star. The objects it encapsulates also derive from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class.</p>
<ul>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Spacetime</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class. It represents the ambient Schwarzschild spacetime solution.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class. It represents a radiation field on a 2-surface embedded in a spacelike hypersurface of that ambient spacetime. There can be multiple <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instances per <code class="docutils literal notranslate"><span class="pre">Star</span></code> instance, naturally representing <em>snapshots</em> in time that are assumed to be adequate approximations for some natural number of stellar rotations. Note that the dimensionality of the parameter space grows linearly, however, so in practice this
approximation to time evolution is intended for simulation and data synthesis.</p>
<ul>
<li><p>A <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class. It represents a radiatively intense region: e.g., a “circular hot-spot” in the photosphere (the surface radiation field). Alternatively, a <code class="docutils literal notranslate"><span class="pre">TwoHotRegions</span></code> object that derives from <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code>, or a <code class="docutils literal notranslate"><span class="pre">HotRegions</span></code> object that encapsulates references to two or more <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> instances, is used.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">Elsewhere</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class. The represents the surface radiation field exterior to the hot region.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">Everywhere</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class. The represents the surface radiation field <em>everywhere</em>, and <em>cannot</em> be used in conjuction with <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> instances and <code class="docutils literal notranslate"><span class="pre">Elsewhere</span></code> instances.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Signal</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class, and is itself an abstract base class. A signal is defined as a subset <span class="math notranslate nohighlight">\(\mathcal{D}_{i}\subseteq\mathcal{D}\)</span> of the dataset with a parametrised sampling distribution dependent on an incident specific flux signal generated by a particular <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance. There can thus be multiple <code class="docutils literal notranslate"><span class="pre">Signal</span></code> instances.</p>
<ul>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Data</span></code> instance does <em>not</em> derive from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class, and is a concrete class. It is a container for the data subset <span class="math notranslate nohighlight">\(\mathcal{D}_{i}\subseteq\mathcal{D}\)</span>.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">Instrument</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class, and is a concrete class. It represents the model instrument for transforming incident specific flux signals into a structure which directly enters the parameterised sampling distribution of <span class="math notranslate nohighlight">\(\mathcal{D}_{i}\)</span>.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">Interstellar</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class, and is itself an abstract base class. It represents a model for physical interstellar radiation-matter interaction processes which modify the surface radiation field during propagation to the instrument.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Background</span></code> instance derives from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class, and is itself an abstract base class. It represents a model for the background radiation field <em>incident</em> on the instrument.</p></li>
</ul>
</li>
</ul>
<p>The purpose of invoking the object-oriented paradigm here is to organise a non-trivial likelihood evaluation algorithm in a <em>logical</em>, <em>flexible</em>, and <em>extensible</em> manner by identifying groups of mathematical structures which can be considered as belonging to some more abstract object with some physical and/or statistical meaning, and <em>modularising</em> them in classes.</p>
<p>We use a dynamic and expressive high-level language to organise this computation, allowing both calls low-level library routines where necessary to improve calculation speed, and straightforward communication between our problem-specific code and other more general open-source software libraries (in particular, statistical sampling software).</p>
<p>As stated above, for each of these objects which derive from the <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> class, their parameter subspaces are merged into a higher-dimensional space when referenced by an object higher in the hierarcy. As an example, a <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> instance and an <code class="docutils literal notranslate"><span class="pre">Elsewhere</span></code> instance each have an associated parameter subspace, and those are merged to form most of the dimensions of the parameter space associated with a <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance.</p>
<p>Note that one can in principle utilise a given object multiple times. An example would be the use of the same <code class="docutils literal notranslate"><span class="pre">Instrument</span></code> object or <code class="docutils literal notranslate"><span class="pre">Interstellar</span></code> processes object for constructing multiple <code class="docutils literal notranslate"><span class="pre">Signal</span></code> objects, although this might result in too many parameter dimensions for a problem to be tractable. On another level, the instruments might reference some of the same <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> objects, but themselves be distinct objects, each passed to a distinct <code class="docutils literal notranslate"><span class="pre">Signal</span></code> object. In the diagram below we
illustrate a <em>tied</em> relationship between some objects with connecting lines: this could mean the tied objects are <em>the same</em> object, or that the objects share some parameters, or that properties of one are derived from the free parameters of another.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Image(&quot;./_static/oop_modelling_diagram_v2.png&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_15_0.png" src="_images/Modeling_15_0.png" />
</div>
</div>
<p>In this case, the tied objects represent physical systems or processes exisiting at different times, but some behaviour is shared. Note that we also assumed that the <code class="docutils literal notranslate"><span class="pre">Interstellar</span></code> processes are time-invariant and thus moved the object over to connect to the <code class="docutils literal notranslate"><span class="pre">Star</span></code> itself; the source code is not structured quite in this way, but achieves the same if an <code class="docutils literal notranslate"><span class="pre">Interstellar</span></code> process object is time-invariant. The <code class="docutils literal notranslate"><span class="pre">Data</span></code> objects are never parametrised and thus are not tied in the sense discussed
above.</p>
<p>Another example might be supplying the same hot-region radiation field parameters to two <em>disjoint</em> hot regions that simultaneously occupy a subset of the stellar surface. In this case the <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> objects referenced in the <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> objects would be shared. Another way to achieve the same effect is to define parameters of one hot region as <em>derived</em> from those of the other hot region. Both methods would achieve the same goal, but would be implemented differently. The latter is more
flexible and thus more powerful. More extensive examples of this paradigm are given in a separate tutorial.</p>
<p>If there are instantaneously multiple <em>disjoint</em> surface hot regions, the model object hierarchy diagram would more accurately be rendered as:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Image(&quot;./_static/oop_modelling_diagram_v3.png&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_19_0.png" src="_images/Modeling_19_0.png" />
</div>
</div>
<p>If there are multiple instances of the <a class="reference internal" href="photosphere.html#xpsi.Photosphere.Photosphere"><span class="std std-ref">Photosphere</span></a> class, and multiple instances of the <a class="reference internal" href="signal.html#xpsi.Signal.Signal"><span class="std std-ref">Signal</span></a> class with a one-to-one mapping, the parameter set would assume the following form:</p>
<ul class="simple">
<li><p>coordinate spin frequency</p></li>
<li><p>(rotationally deformed) gravitational mass</p></li>
<li><p>coordinate equatorial radius</p></li>
<li><p>distance from Earth</p></li>
<li><p>inclination of Earth to stellar rotation axis</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">photosphere_1</span></code> (non-optional):</p>
<ul>
<li><p>coordinate rotation frequency of a mode of radiative asymmetry assumed to generate the observed pulsations</p></li>
<li><p>subvector of geometric hot-region parameters (e.g., spot centre colatitude, spot angular radius, and so on) and a parameter controlling the surface local-comoving-frame radiation field <em>within</em> the region boundaries</p></li>
<li><p>(optional) subvector of additional parameters controlling the surface local-comoving-frame radiation field <em>within</em> the hot-region boundaries (e.g., pertaining to ionisation degree or composition)</p></li>
<li><p>(optional) subvector of parameters controlling the surface local-comoving-frame radiation field <em>outside</em> the hot-region boundaries</p></li>
<li><p>subvector of fast parameters for the phases of the hot region(s) relative to some fiducial phase</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(\ldots\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">photosphere_n</span></code> (optional):</p>
<ul>
<li><p>coordinate rotation frequency of a mode of radiative asymmetry assumed to generate the observed pulsations</p></li>
<li><p>subvector of geometric hot-region parameters (e.g., spot centre colatitude, spot angular radius, and so on) and a parameter such as an effective temperature controlling the surface local-comoving-frame radiation field <em>within</em> the region boundaries</p></li>
<li><p>(optional) subvector of additional parameters controlling the surface local-comoving-frame radiation field <em>within</em> the hot-region boundaries (e.g., pertaining to ionisation degree or composition)</p></li>
<li><p>(optional) subvector of parameters controlling the surface local-comoving-frame radiation field <em>outside</em> the hot-region boundaries</p></li>
<li><p>subvector of fast parameters for the phases of the hot region(s) relative to some fiducial phase</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">signal_1</span></code> (non-optional):</p>
<ul>
<li><p>(optional) subvector of fast nuisance parameters associated with interstellar processes</p></li>
<li><p>(optional) subvector of fast nuisance parameters associated with instrument response</p></li>
<li><p>(optional) subvector of fast nuisance parameters associated with background processes</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(\ldots\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">signal_n</span></code> (if matching <code class="docutils literal notranslate"><span class="pre">photosphere_n</span></code>):</p>
<ul>
<li><p>(optional) subvector of fast nuisance parameters associated with interstellar processes</p></li>
<li><p>(optional) subvector of fast nuisance parameters associated with instrument response</p></li>
<li><p>(optional) subvector of fast nuisance parameters associated with background processes</p></li>
</ul>
</li>
</ul>
<p>where <span class="math notranslate nohighlight">\(\forall i\in[1,n]\)</span> <code class="docutils literal notranslate"><span class="pre">photosphere_i</span></code> and <code class="docutils literal notranslate"><span class="pre">signal_i</span></code> share an identification <code class="docutils literal notranslate"><span class="pre">tag</span></code>.</p>
<p>Most model parameters that are <em>not</em> associated with <code class="docutils literal notranslate"><span class="pre">Signal</span></code> instances are considered <em>slow</em> parameters; see the interlude below for definition of <em>slow</em> and <em>fast</em>. An example of a <em>slow</em> parameter is the gravitational mass, whilst examples of <em>fast</em> parameters are the initial phase of the photosphere and the distance (from Earth) to the star.</p>
<p>Yet another paradigm is that the same signal yielded by integrating over the photosphere is operated on by multiple instruments (on different telescopes or the same telescope, or some on one telecope and others on other telescopes), and because these instruments are synergystic probes of the physical signal-generating process, we aim to jointly model the data from those instruments. This can be executed as follows:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Image(&quot;./_static/oop_modelling_diagram_v4.png&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_22_0.png" src="_images/Modeling_22_0.png" />
</div>
</div>
<p>Here the signal from integrating over the image of the <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance is relayed to all <code class="docutils literal notranslate"><span class="pre">Signal</span></code> instances for instrument operation and likelihood function calculation. The signal relayed is always encapsulated by a 2D NumPy array with photon energy increasing with row (zeroth dimension) and phase increasing with column (first dimension). Even if an integrator (extension module) is called that assumes time-invariance of the image of the <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> and thus returns a single
spectrum, that spectrum is encapsulated by a 2D NumPy array. Specifically, an <code class="docutils literal notranslate"><span class="pre">Elsewhere</span></code> instance returns a spectrum which is added to the spectrum at each phase generated by the associated <code class="docutils literal notranslate"><span class="pre">HotRegion(s)</span></code> instance. The user can then completely phase-average the signal (thus generating a single spectrum) for comparison to an instrument whose registered (and pre-processed) data is a spectrum. For instruments that register time-resolved data, the user will usually integrate the signal phase
intervals (bins) for likelihood function evaluation. The phase-resolved and phase-averaged data can be jointly modeled.</p>
<p>Finally, one can use <code class="docutils literal notranslate"><span class="pre">Everywhere</span></code> instances to model the surface radiation field everywhere, but these instances cannot be used in conjuction with <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> instances nor <code class="docutils literal notranslate"><span class="pre">Elsewhere</span></code> instances to constitute the same <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance. An example of this paradigm is as follows:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Image(&quot;./_static/oop_modelling_diagram_v5.png&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_25_0.png" src="_images/Modeling_25_0.png" />
</div>
</div>
<p>Note that here we chose to return to the notion of time-evolution between <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instances, instead of using multiple <code class="docutils literal notranslate"><span class="pre">Signal</span></code> intances operating on one <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance.</p>
</section>
<section id="Interlude:-fast-and-slow-parameters">
<h3>Interlude: fast and slow parameters<a class="headerlink" href="#Interlude:-fast-and-slow-parameters" title="Link to this heading"></a></h3>
<p>A subset of model parameters are <em>slow</em> because varying those parameters requires <em>likelihood</em> re-evaluation, and the compute time required to perform that re-evaluation is slow <em>relative</em> to re-evaluation when varying only a distinct <em>subset</em> of the model parameters: the <em>fast</em> parameters. In general there can be multiple subsets of parameters forming a <em>speed hierarchy</em>; see <a class="reference external" href="https://arxiv.org/abs/1304.4473">A. Lewis, “Efficient sampling of fast and slow cosmological parameters”
(arXiv:1304.4473)</a>.</p>
<p>X-PSI, during developement, supported the use of the nested sampler PolyChord, whose internals require that parameters forming a speed hierarchy are ordered in subsets (or blocks) from <em>slow</em> to <em>fast</em> in an array passed to a <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> callback function (if one wishes to exploit a speed hierarchy that is). Thus the ordering of an array of parameter values passed to a general instance of the <a class="reference internal" href="likelihood.html#xpsi.Likelihood.Likelihood"><span class="std std-ref">Likelihood</span></a> class was of crucial importance. During
development, we opted to support the nested sampler MultiNest instead based on the nature of the sampling problem (dimensionality and likelihood evaluation expense).</p>
<p>However, until X-PSI <code class="docutils literal notranslate"><span class="pre">v0.3</span></code>, a convention for parameter ordering for likelihood evaluation was imposed, with two basic speed grades. In <code class="docutils literal notranslate"><span class="pre">v0.3</span></code>, however, we do not adhere to a speed hierarchy for lack of an application at present, although with some added sophistication this can be supported.</p>
</section>
<section id="Data">
<h3>Data<a class="headerlink" href="#Data" title="Link to this heading"></a></h3>
<p>For the analysis in this notebook we consider all data <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> to be drawn from a joint sampling distribution whose dependency on <em>slow</em> model source parameters is expressed in terms of a <em>single</em> pulse signal. The justification for such an assumption is that we are performing parameter estimation given a synthetic data set for a model <em>pulsar</em> with a stable (effectively non-evolving) surface radiation field, with any quasi-periodicity arising solely from relative orbital motion of
source and telescope. The synthetic data is intended to emulate detection of photons over a long observing run, after which the photon incidence events are phase-folded during a pre-processing phase.</p>
<p>This parameter estimation excercise is not <em>blind</em>: we know the parameter values injected to generate the synthetic dataset we will later load into a custom container.</p>
<p>We do not need to subclass data container, but you can if you wish. X-PSI is designed this way because there is a clear common usage pattern that can be concretely implemented whilst preserving the freedom and the scope of applicability of the source code. The container instance will be available as an underscore instance method of <a class="reference internal" href="signal.html#xpsi.Signal.Signal"><span class="std std-ref">Signal</span></a>, and thus available in a derived class where we will later write code for likelihood evaluation.</p>
<p>Hereafter we will write our custom derived classes in the notebook itself, but in practice it is best if your derived classes are written in distinct modules within a project directory, so they can be imported by a script for use with an MPI command within a shell (because in general we want to exploit parallelism for expensive likelihood evaluations).</p>
<p>Let us load a synthetic data set that we generated in advance, and know the fictitious exposure time for:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>settings = dict(counts = np.loadtxt(&#39;../../examples/examples_modeling_tutorial/model_data/example_synthetic_realisation.dat&#39;, dtype=np.double),
                channels=np.arange(20,201),
                phases=np.linspace(0.0, 1.0, 33),
                first=0, last=180,
                exposure_time=984307.6661)

data = xpsi.Data(**settings)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Setting channels for event data...
Channels set.
</pre></div></div>
</div>
<p>For real data, the X-ray telescope processing pipeline usually result in an event file (EVT) or spectrum (PHA). X-PSI can fit both, but there is not timing information in PHA file. Those can be loaded with <code class="docutils literal notranslate"><span class="pre">xpsi.Data.load(file_path,n_phases=32,</span> <span class="pre">channels=None,</span> <span class="pre">phase_column='PULSE_PHASE',</span> <span class="pre">channel_column='PI')</span></code> where :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">file_path</span></code> points to an EVT or PHA file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_phase</span></code> is the number of phase bins ro divide the data into if this is an EVT file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channels</span></code> gives list of channels to extract</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phase_column</span></code> is the column to take the phase values from if this is an EVT file</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel_column</span></code> is the column to take the channel values from if this is an EVT file</p></li>
</ul>
<p>Let’s take a look at the data that we aim to model. We can plot it with a built in function :</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, axs = data.plot( dpi=100 , colormap=&#39;inferno&#39; , num_rot=2)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_36_0.png" src="_images/Modeling_36_0.png" />
</div>
</div>
<p>We can trim it and replot it</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data.trim_data(min_channel=30, max_channel=180 )
fig, axs = data.plot( dpi=100 , colormap=&#39;inferno&#39; , num_rot=2)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Trimming event data...
Event data trimmed.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_38_1.png" src="_images/Modeling_38_1.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Let&#39;s go back to the first configuration
data = xpsi.Data(**settings)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Setting channels for event data...
Channels set.
</pre></div></div>
</div>
</section>
<section id="Instrument">
<h3>Instrument<a class="headerlink" href="#Instrument" title="Link to this heading"></a></h3>
<p>We require a model instrument object to transform incident specific flux signals into a form which enters directly in the sampling distribution of the data.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class CustomInstrument(xpsi.Instrument):
    &quot;&quot;&quot; A model of the NICER telescope response. &quot;&quot;&quot;

    def __call__(self, signal, *args):
        &quot;&quot;&quot; Overwrite base just to show it is possible.

        We loaded only a submatrix of the total instrument response
        matrix into memory, so here we can simplify the method in the
        base class.

        &quot;&quot;&quot;
        matrix = self.construct_matrix()

        self._folded_signal = np.dot(matrix, signal)

        return self._folded_signal
</pre></div>
</div>
</div>
<p>Let’s construct an instance.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>NICER = CustomInstrument.from_ogip_fits(RMF_path=&#39;nicer_20170601v003.rmf&#39;,
                                        ARF_path=&#39;nicer_20170601v005.arf&#39;,
                                        datafolder=&#39;../../examples/examples_modeling_tutorial/model_data&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Loading instrument response matrix from OGIP compliant files...
Triming the response matrix because it contains columns with only 0 values.
 Now min_channel=9 and max_channel=1500
Setting channels for loaded instrument response (sub)matrix...
Channels set.
An empty subspace was created. This is normal behavior - no parameters were supplied.
Response matrix loaded.
</pre></div></div>
</div>
<p>The NICER response matrix is non-diagonal because some energy ranges are oversampled.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>energy_inputs = np.arange(1,len( NICER.energy_edges)+1)-0.5
channels = NICER.channel_edges * 100 - 0.5

rmf_plot = XpsiPlot.plot_rmf(matrix=NICER.matrix,
                             x=energy_inputs,
                             y=channels,
                             xlabel=&#39;Energy interval&#39;,
                             ylabel=&#39;Channels&#39;
                            )

XpsiPlot.veneer((200, 1000), (50, 100), rmf_plot)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_46_0.png" src="_images/Modeling_46_0.png" />
</div>
</div>
<p>The response is large, let’s trim it for plotting</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>NICER.trim_response(min_channel=20, max_channel=200, threshold=2.)
print( NICER.matrix.shape )

# Update the x and y arrays for the plot
energy_inputs = np.arange(1,len( NICER.energy_edges)+1)-0.5
channels = NICER.channel_edges * 100 - 0.5

rmf_plot = XpsiPlot.plot_rmf(matrix=NICER.matrix,
                             x=energy_inputs,
                             y=channels,
                             xlabel=&#39;Energy interval&#39;,
                             ylabel=&#39;Channels&#39;
                            )
XpsiPlot.veneer((50, 200), (10, 50), rmf_plot)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Trimming instrument response...
Setting channels for loaded instrument response (sub)matrix...
Channels set.
Triming the response matrix because it contains rows with only values &lt;= 2.0.
 Now min_energy=0.17499999701976776 and max_energy=2.2260000705718994
Instrument response trimmed.
(181, 1135)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_48_1.png" src="_images/Modeling_48_1.png" />
</div>
</div>
<p>Plotting now with the energy values</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>rmf_plot = XpsiPlot.plot_rmf(matrix=NICER.matrix,
                             x=NICER.energy_edges,
                             y=NICER.channel_edges,
                             xlabel=&#39;Energy bin [keV]&#39;,
                             ylabel=&#39;Channel energy [keV]&#39;,
                            )
XpsiPlot.veneer((0.1, 0.5), (0.1, 0.5), rmf_plot)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_50_0.png" src="_images/Modeling_50_0.png" />
</div>
</div>
<p>Summed over channel subset <span class="math notranslate nohighlight">\([20,200]\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>arfplot = XpsiPlot.plot_arf([NICER])
XpsiPlot.veneer((0.1, 0.5), (100, 500), arfplot)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_52_0.png" src="_images/Modeling_52_0.png" />
</div>
</div>
</section>
<section id="Signal">
<h3>Signal<a class="headerlink" href="#Signal" title="Link to this heading"></a></h3>
<p>We can now combine the dataset and model instrument into a <a class="reference internal" href="signal.html#xpsi.Signal.Signal"><span class="std std-ref">Signal</span></a> object. The source code for this class has methods and attributes which simplify communication between the aforementioned model objects and another object representing our model star (created below). The surface radiation field of the model star is integrated over based on energies relayed from a <a class="reference internal" href="signal.html#xpsi.Signal.Signal"><span class="std std-ref">Signal</span></a> object based on the properties of the instrument and the
dataset (which are tightly coupled).</p>
<p>We are forced to inherit from <a class="reference internal" href="signal.html#xpsi.Signal.Signal"><span class="std std-ref">Signal</span></a> and write a method that evaluates the logarithm of the likelihood conditional on a parametrised sampling distribution for the data. There is much freedom in constructing this sampling distribution, so the design strategy for X-PSI was to leave this part of the modelling process entirely to a user, guided by a number of examples. The only condition for applicability is that the sampling distribution of the data (or of each
subset) can be written in terms of a set of <em>single</em> count-rate pulses.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from xpsi.likelihoods.default_background_marginalisation import eval_marginal_likelihood
from xpsi.likelihoods.default_background_marginalisation import precomputation

class CustomSignal(xpsi.Signal):
    &quot;&quot;&quot;

    A custom calculation of the logarithm of the likelihood.
    We extend the :class:`~xpsi.Signal.Signal` class to make it callable.
    We overwrite the body of the __call__ method. The docstring for the
    abstract method is copied.

    &quot;&quot;&quot;

    def __init__(self, workspace_intervals = 1000, epsabs = 0, epsrel = 1.0e-8,
                 epsilon = 1.0e-3, sigmas = 10.0, support = None, **kwargs):
        &quot;&quot;&quot; Perform precomputation.

        :params ndarray[m,2] support:
            Prior support bounds for background count rate variables in the
            :math:`m` instrument channels, where the lower bounds must be zero
            or positive, and the upper bounds must be positive and greater than
            the lower bound. Alternatively, setting the an upper bounds as
            negative means the prior support is unbounded and the flat prior
            density functions per channel are improper. If ``None``, the lower-
            bound of the support for each channel is zero but the prior is
            unbounded.

        &quot;&quot;&quot;

        super(CustomSignal, self).__init__(**kwargs)

        try:
            self._precomp = precomputation(self._data.counts.astype(np.int32))
        except AttributeError:
            print(&#39;Warning: No data... can synthesise data but cannot evaluate a &#39;
                  &#39;likelihood function.&#39;)
        else:
            self._workspace_intervals = workspace_intervals
            self._epsabs = epsabs
            self._epsrel = epsrel
            self._epsilon = epsilon
            self._sigmas = sigmas

            if support is not None:
                self._support = support
            else:
                self._support = -1.0 * np.ones((self._data.counts.shape[0],2))
                self._support[:,0] = 0.0

    def __call__(self, *args, **kwargs):
        self.loglikelihood, self.expected_counts, self.background_signal, self.background_given_support = \
                eval_marginal_likelihood(self._data.exposure_time,
                                          self._data.phases,
                                          self._data.counts,
                                          self._signals,
                                          self._phases,
                                          self._shifts,
                                          self._precomp,
                                          self._support,
                                          self._workspace_intervals,
                                          self._epsabs,
                                          self._epsrel,
                                          self._epsilon,
                                          self._sigmas,
                                          kwargs.get(&#39;llzero&#39;),
                                          allow_negative=(False, False))
</pre></div>
</div>
</div>
<p>In the first part of this notebook we define a <em>marginal</em> likelihood function. That is, instead of invoking the true background model that in this case is known to us, we invoke a default treatment whereby we marginalise over a set of channel-by-channel background count-rate parameters instead.</p>
<p>We wrote our <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method as a wrapper for a extension module to improve speed. The source code for the simpler case of parameter estimation when the background model is known (see path <code class="docutils literal notranslate"><span class="pre">xpsi/examples/true_background</span></code>). In general, if you wish to change the model for likelihood evaluation given expected signals, you can archive the Cython extensions in, e.g., the <code class="docutils literal notranslate"><span class="pre">xpsi/likelihoods</span></code> directory, and compile these when X-PSI is compiled and installed (by editing the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script).
Alternatively, you can compile your extension elsewhere and call those compiled binaries from your custom class derived from <code class="docutils literal notranslate"><span class="pre">Signal</span></code>.</p>
<p>Let’s construct and instantiate a <code class="docutils literal notranslate"><span class="pre">Signal</span></code> object. We must accept phase shift parameters, which are a <em>fast</em> nuisance parameter; this detailed in the docstring of <code class="docutils literal notranslate"><span class="pre">Signal</span></code>. The bounds of the background parameter have already been specified above.</p>
<p><strong>In practice, the data and instrument are trimmed in this step and should not be trimmed before.</strong> This is done here because we are using a toy model and not FITS data.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>signal = CustomSignal(data = data,
                        instrument = NICER,
                        background = None,
                        interstellar = None,
                        workspace_intervals = 1000,
                        cache = True,
                        epsrel = 1.0e-8,
                        epsilon = 1.0e-3,
                        sigmas = 10.0,
                        min_channel = 20,
                        max_channel = 200,
                        support = None)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Trimming event data...
Event data trimmed.
Trimming instrument response...
Setting channels for loaded instrument response (sub)matrix...
Channels set.
Instrument response trimmed.
Creating parameter:
    &gt; Named &#34;phase_shift&#34; with fixed value 0.000e+00.
    &gt; The phase shift for the signal, a periodic parameter [cycles].
</pre></div></div>
</div>
</section>
<section id="Constructing-a-star">
<h3>Constructing a star<a class="headerlink" href="#Constructing-a-star" title="Link to this heading"></a></h3>
<p>We now need to build our star. The basic units for building a star are:</p>
<ul class="simple">
<li><p>the <a class="reference internal" href="spacetime.html#xpsi.Spacetime.Spacetime"><span class="std std-ref">Spacetime</span></a> class;</p></li>
<li><p>the <a class="reference internal" href="photosphere.html#xpsi.Photosphere.Photosphere"><span class="std std-ref">Photosphere</span></a> class;</p></li>
<li><p>the <a class="reference internal" href="hotregion.html#xpsi.HotRegion.HotRegion"><span class="std std-ref">HotRegion</span></a> class;</p></li>
<li><p>the <a class="reference internal" href="elsewhere.html#xpsi.Elsewhere.Elsewhere"><span class="std std-ref">Elsewhere</span></a> class;</p></li>
<li><p>and four low-level user-modifiable routines for evaluation of a parametrised specific intensity model.</p></li>
</ul>
<p>For this demonstration we will assume that the surface radiation field <em>elsewhere</em> (other than the hot regions) can be ignored in the soft X-ray regime our model instrument is sensitive to. For more advanced modelling, we can simply write custom <em>derived</em> classes, and instantiate those derived classes to construct objects for our model. In particular, a common pattern will be to subclass the <a class="reference internal" href="hotregion.html#xpsi.HotRegion.HotRegion"><span class="std std-ref">HotRegion</span></a> class. Let’s start with the
<a class="reference internal" href="spacetime.html#xpsi.Spacetime.Spacetime"><span class="std std-ref">Spacetime</span></a> class.</p>
<section id="The-ambient-spacetime">
<h4>The ambient spacetime<a class="headerlink" href="#The-ambient-spacetime" title="Link to this heading"></a></h4>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.Spacetime#? # uncomment to query
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
xpsi.Spacetime.Spacetime
</pre></div></div>
</div>
<p>We can instanciate the <code class="docutils literal notranslate"><span class="pre">spacetime</span></code> by defining all parameters with a given value. In this case, all parameters will be fixed because the <code class="docutils literal notranslate"><span class="pre">bounds</span></code> are not specified (empty dictionary). <strong>Note that all parameters must be defined at least once in ``bounds`` or ``values``.</strong></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>values = dict(distance =0.150,          # (Earth) distance
                mass = 1.5,             # mass
                radius = 12.0,          # equatorial radius
                cos_inclination = 0.5,  # (Earth) inclination to rotation axis
                frequency = 300. )      # spin frequency

spacetime = xpsi.Spacetime(bounds={}, values=values)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;frequency&#34; with fixed value 3.000e+02.
    &gt; Spin frequency [Hz].
Creating parameter:
    &gt; Named &#34;mass&#34; with fixed value 1.500e+00.
    &gt; Gravitational mass [solar masses].
Creating parameter:
    &gt; Named &#34;radius&#34; with fixed value 1.200e+01.
    &gt; Coordinate equatorial radius [km].
Creating parameter:
    &gt; Named &#34;distance&#34; with fixed value 1.500e-01.
    &gt; Earth distance [kpc].
Creating parameter:
    &gt; Named &#34;cos_inclination&#34; with fixed value 5.000e-01.
    &gt; Cosine of Earth inclination to rotation axis.
</pre></div></div>
</div>
<p>Alternatively we can specify bounds manually for the free parameters. Using <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> will set the default bounds. The fixed parameters are defined in the <code class="docutils literal notranslate"><span class="pre">values</span></code> dictionary. If both the bounds and a value are defined for a parameters, the value will not be fixed but instead will be set as an initial value.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>bounds = dict(distance = (None, None),                   # Default bounds for (Earth) distance
                mass = (None, None),                     # Default bounds for mass
                radius = (None, None),                   # Default bounds for equatorial radius
                cos_inclination = (None, None))          # Default bounds for (Earth) inclination to rotation axis

values = dict(frequency=300.0,                           # Fixed spin frequency
              mass=1.4)                                  # mass with initial value

spacetime = xpsi.Spacetime(bounds=bounds, values=values)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;frequency&#34; with fixed value 3.000e+02.
    &gt; Spin frequency [Hz].
Creating parameter:
    &gt; Named &#34;mass&#34; with bounds [1.000e-03, 3.000e+00] and initial value 1.400e+00.
    &gt; Gravitational mass [solar masses].
Creating parameter:
    &gt; Named &#34;radius&#34; with bounds [1.000e+00, 2.000e+01].
    &gt; Coordinate equatorial radius [km].
Creating parameter:
    &gt; Named &#34;distance&#34; with bounds [1.000e-02, 3.000e+01].
    &gt; Earth distance [kpc].
Creating parameter:
    &gt; Named &#34;cos_inclination&#34; with bounds [-1.000e+00, 1.000e+00].
    &gt; Cosine of Earth inclination to rotation axis.
</pre></div></div>
</div>
<p>To display the free parameters:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for p in spacetime:
    print(p)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Gravitational mass [solar masses].
Coordinate equatorial radius [km].
Earth distance [kpc].
Cosine of Earth inclination to rotation axis.
</pre></div></div>
</div>
<p>For the following example in this tutorial, we will specify the bounds of all parameters.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>bounds = dict(distance = (0.1, 1.0),                     # (Earth) distance
                mass = (1.0, 3.0),                       # mass with default bounds
                radius = (3.0 * gravradius(1.0), 16.0),  # equatorial radius
                cos_inclination = (0.0, 1.0))            # (Earth) inclination to rotation axis

values = dict(frequency=300.0 )                          # Fixed spin frequency

spacetime = xpsi.Spacetime(bounds=bounds, values=values)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;frequency&#34; with fixed value 3.000e+02.
    &gt; Spin frequency [Hz].
Creating parameter:
    &gt; Named &#34;mass&#34; with bounds [1.000e+00, 3.000e+00].
    &gt; Gravitational mass [solar masses].
Creating parameter:
    &gt; Named &#34;radius&#34; with bounds [4.430e+00, 1.600e+01].
    &gt; Coordinate equatorial radius [km].
Creating parameter:
    &gt; Named &#34;distance&#34; with bounds [1.000e-01, 1.000e+00].
    &gt; Earth distance [kpc].
Creating parameter:
    &gt; Named &#34;cos_inclination&#34; with bounds [0.000e+00, 1.000e+00].
    &gt; Cosine of Earth inclination to rotation axis.
</pre></div></div>
</div>
</section>
<section id="The-photosphere-and-its-constituent-regions">
<h4>The photosphere and its constituent regions<a class="headerlink" href="#The-photosphere-and-its-constituent-regions" title="Link to this heading"></a></h4>
<p>It is not necessary for us to write a custom derived class for the photosphere object, so we will simply instantiate a <a class="reference internal" href="photosphere.html#xpsi.Photosphere.Photosphere"><span class="std std-ref">Photosphere</span></a> object. However, we first need an instance of <a class="reference internal" href="hotregion.html#xpsi.HotRegion.HotRegion"><span class="std std-ref">HotRegion</span></a> to instantiate the photosphere, and we need to implement a low-level parametrised model for the specific intensity emergent from the photosphere in a local comoving frame.</p>
<p>The neutron star atmosphere is assumed to be geometrically thin. In the applications thus far, the surface local-comoving-frame radiation field as being described by a single <em>free</em> parameter: the effective temperature. The radiation field is also dependent on the local effective gravitational acceleration, however this is a <em>derived</em> parameter in the model. The parametrised radiation field as a function of energy and angle subtended to the normal to the (plane-parallel) atmosphere in a local
comoving frame is provided as numerical model data for multi-dimensional interpolation.</p>
<p>In X-PSI, integration over the surface radiation field is performed via calls to low-level C routines. To reduce likelihood evaluation times, the atmosphere interpolator is written in C, and calls to that interpolator are from C routine. In other words, in X-PSI, <strong>we do not use Python callback functions for evaluation of specific intensities, but C functions which are compiled when the</strong> X-PSI <strong>package is built</strong>. Unfortunately this means that to change the parametrised surface radiation field
you need to get your hands a little dirty; on the bright side, the body of these functions can be implemented almost completely in the Cython language, so syntactically there is some similarity to Python because the language syntax is somewhat of a hybrid/superset. Beware, however, that the body of these functions must not contain calls to the Python API, and only to external C libraries if required: the code must evaluate to pure C, and not require the Python/C API. Note that the Python global
interpreter lock is deactivated during integration to enable OpenMP multi-threading in some applications of the integrator; thus the code needs to be thread safe and <code class="docutils literal notranslate"><span class="pre">nogil</span></code> (not require the global interpreter lock, although a context manager could <em>in principle</em> be used to reacquire the lock within the integrator). Also note that if external C libraries are required, that you include a Cython .pxd (header) file in the package which <code class="docutils literal notranslate"><span class="pre">extern</span></code>s the required library components; the library
also needs to be included and linked in <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> at package build-time.</p>
<p><em>You are encouraged to ask the authors of X-PSI for assistance in implementing your low-level surface radiation field model if you are uncertain. If you have ideas for making this model specification more user-friendly, without, crucially, increasing signal integration time, please contact the author or submit a pull request.</em></p>
<p>There are several atmosphere extension modules for users and developers to work with; <code class="docutils literal notranslate"><span class="pre">hot_BB.pyx</span></code>, and <code class="docutils literal notranslate"><span class="pre">hot_Num4D.pyx</span></code> are the built-in options for isotropic blackbody radiation field and numerical 4D-interpolation from a preloaded atmosphere table, and they can be selected with the <code class="docutils literal notranslate"><span class="pre">atm_ext</span></code> option when creating instances of the radiating regions (from <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code>, <code class="docutils literal notranslate"><span class="pre">Elsewhere</span></code>, or <code class="docutils literal notranslate"><span class="pre">Everywhere</span></code> classes); <code class="docutils literal notranslate"><span class="pre">hot_user.pyx</span></code> and <code class="docutils literal notranslate"><span class="pre">elsewhere_user.pyx</span></code> are additional extensions which can
be replaced by user-developed versions, and used after re-installing X-PSI and setting <code class="docutils literal notranslate"><span class="pre">atm_ext=&quot;user&quot;</span></code> (by default they are the same as <code class="docutils literal notranslate"><span class="pre">hot_BB.pyx</span></code>).</p>
<p><strong>Note that in X-PSI versions before 2.1.0 the selection of the atmosphere extension needed to be done when installing X-PSI (using installation flags), and not using the atm_ext option as now.</strong></p>
<p>The following is the contents of the <code class="docutils literal notranslate"><span class="pre">hot_user.pxd</span></code> file which the X-PSI integrators use as the header file for including other C functions in the package (if using the non-modified “user” option).</p>
<div class="highlight-cython notranslate"><div class="highlight"><pre><span></span><span class="k">from</span><span class="w"> </span><span class="nn">.preload</span><span class="w"> </span><span class="k">cimport</span> <span class="n">_preloaded</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">eval_hot_user</span><span class="p">(</span><span class="n">size_t</span> <span class="n">THREAD</span><span class="p">,</span>
                     <span class="n">double</span> <span class="n">E</span><span class="p">,</span>
                     <span class="n">double</span> <span class="n">mu</span><span class="p">,</span>
                     <span class="n">const</span> <span class="n">double</span> <span class="o">*</span><span class="n">const</span> <span class="n">VEC</span><span class="p">,</span>
                     <span class="n">void</span> <span class="o">*</span><span class="n">const</span> <span class="n">data</span><span class="p">)</span> <span class="k">nogil</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">eval_hot_norm_user</span><span class="p">()</span> <span class="k">nogil</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">void</span>* <span class="nf">init_hot_user</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">,</span> <span class="n">const</span> <span class="n">_preloaded</span> <span class="o">*</span><span class="n">const</span> <span class="n">preloaded</span><span class="p">)</span> <span class="k">nogil</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">int</span> <span class="nf">free_hot_user</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">const</span> <span class="n">data</span><span class="p">)</span> <span class="k">nogil</span>
</pre></div>
</div>
<p><strong>You are free to modify these functions in the associated</strong> <code class="docutils literal notranslate"><span class="pre">hot_user.pyx</span></code> <strong>implementation file, and you have almost complete control over the function bodies, but not the signatures.</strong> By default the package includes an isotropic blackbody model:</p>
<div class="highlight-cython notranslate"><div class="highlight"><pre><span></span><span class="c">#cython: cdivision=True</span>
<span class="c">#cython: boundscheck=False</span>
<span class="c">#cython: nonecheck=False</span>
<span class="c">#cython: wraparound=False</span>

<span class="k">from</span><span class="w"> </span><span class="nn">libc.math</span><span class="w"> </span><span class="k">cimport</span> <span class="n">exp</span><span class="p">,</span> <span class="nb">pow</span>
<span class="k">from</span><span class="w"> </span><span class="nn">libc.stdio</span><span class="w"> </span><span class="k">cimport</span> <span class="n">printf</span>

<span class="k">from</span><span class="w"> </span><span class="nn">xpsi.global_imports</span><span class="w"> </span><span class="k">import</span> <span class="n">_keV</span><span class="p">,</span> <span class="n">_k_B</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">int</span> <span class="nf">SUCCESS</span><span class="w"> </span><span class="o">=</span> <span class="mf">0</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">erg</span><span class="w"> </span><span class="o">=</span> <span class="mf">1.0e-7</span>
<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">Planck_dist_const</span><span class="w"> </span><span class="o">=</span> <span class="mf">5.040366110812353e22</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">k_B</span><span class="w"> </span><span class="o">=</span> <span class="n">_k_B</span>
<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">keV</span><span class="w"> </span><span class="o">=</span> <span class="n">_keV</span>
<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">k_B_over_keV</span><span class="w"> </span><span class="o">=</span> <span class="n">k_B</span> <span class="o">/</span> <span class="n">keV</span>

<span class="c">#-----------------------------------------------------------------------&gt;&gt;&gt;</span>
<span class="c"># &gt;&gt;&gt; User modifiable functions.</span>
<span class="c"># &gt;&gt;&gt; Note that the user is entirely free to wrap thread-safe and</span>
<span class="c"># ... non-parallel external C routines from an external library.</span>
<span class="c"># &gt;&gt;&gt; Thus the bodies of the following need not be written explicitly in</span>
<span class="c"># ... the Cython language.</span>
<span class="c">#-----------------------------------------------------------------------&gt;&gt;&gt;</span>
<span class="k">cdef</span><span class="w"> </span><span class="kt">void</span>* <span class="nf">init_hot_user</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">,</span> <span class="n">const</span> <span class="n">_preloaded</span> <span class="o">*</span><span class="n">const</span> <span class="n">preloaded</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c"># This function must match the free management routine free_hot()</span>
    <span class="c"># in terms of freeing dynamically allocated memory. This is entirely</span>
    <span class="c"># the user&#39;s responsibility to manage.</span>

    <span class="k">if</span> <span class="n">preloaded</span> <span class="o">!=</span> <span class="bp">NULL</span> <span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;WARNING: Numerical atmosphere data were preloaded, even though those are not used by this atmosphere extension.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>

    <span class="c"># Return NULL if dynamic memory is not required for the model.</span>
    <span class="k">return</span> <span class="bp">NULL</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">int</span> <span class="nf">free_hot_user</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">const</span> <span class="n">data</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c"># This function must match the initialisation routine init_hot()</span>
    <span class="c"># in terms of freeing dynamically allocated memory. This is entirely</span>
    <span class="c"># the user&#39;s responsibility to manage.</span>
    <span class="c"># The void pointer must be appropriately cast before memory is freed --</span>
    <span class="c"># only the user can know this at compile time.</span>
    <span class="c"># Just use free(&lt;void*&gt; data) iff no memory was dynamically</span>
    <span class="c"># allocated in the function:</span>
    <span class="c">#   init_local_hot()</span>
    <span class="c"># because data is expected to be NULL in this case</span>

    <span class="c">#printf(&quot;\nNo data to be freed.&quot;)</span>

    <span class="k">return</span> <span class="n">SUCCESS</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">eval_hot_user</span><span class="p">(</span><span class="n">size_t</span> <span class="n">THREAD</span><span class="p">,</span>
                     <span class="n">double</span> <span class="n">E</span><span class="p">,</span>
                     <span class="n">double</span> <span class="n">mu</span><span class="p">,</span>
                     <span class="n">const</span> <span class="n">double</span> <span class="o">*</span><span class="n">const</span> <span class="n">VEC</span><span class="p">,</span>
                     <span class="n">void</span> <span class="o">*</span><span class="n">const</span> <span class="n">data</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c"># Arguments:</span>
    <span class="c"># E = photon energy in keV</span>
    <span class="c"># mu = cosine of ray zenith angle (i.e., angle to surface normal)</span>
    <span class="c"># VEC = variables such as temperature, effective gravity, ...</span>
    <span class="c"># data = numerical model data required for intensity evaluation</span>

    <span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">temp</span><span class="w"> </span><span class="o">=</span> <span class="n">k_B_over_keV</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">VEC</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">E</span> <span class="o">*</span> <span class="n">E</span> <span class="o">*</span> <span class="n">E</span> <span class="o">/</span> <span class="p">(</span> <span class="n">exp</span><span class="p">(</span><span class="n">E</span> <span class="o">/</span> <span class="n">temp</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="p">)</span>

<span class="k">cdef</span><span class="w"> </span><span class="kt">double</span> <span class="nf">eval_hot_norm_user</span><span class="p">()</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c"># Source radiation field normalisation which is independent of the</span>
    <span class="c"># parameters of the parametrised model -- i.e. cell properties, energy,</span>
    <span class="c"># and angle.</span>
    <span class="c"># Writing the normalisation here reduces the number of operations required</span>
    <span class="c"># during integration.</span>
    <span class="c"># The units of the specific intensity need to be J/cm^2/s/keV/steradian.</span>

    <span class="k">return</span> <span class="n">erg</span> <span class="o">*</span> <span class="n">Planck_dist_const</span>
</pre></div>
</div>
<p>In most use-cases we apply the <code class="docutils literal notranslate"><span class="pre">hot_Num4D.pyx</span></code> extension to handle the numerical atmosphere data. This extension is presented in <a class="reference internal" href="surface_radiation_field.html#a-numerical-atmosphere"><span class="std std-ref">surface radiation field extension module</span></a>, and is essentially the same as used by <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...887L..21R/abstract">Riley et al. (2019)</a> (and the follow-up papers) to implement a numerical atmosphere generated by the NSX atmosphere code (<a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2001MNRAS.327.1081H/abstract">Ho &amp; Lai
(2001)</a>; <a class="reference external" href="https://ui.adsabs.harvard.edu/link_gateway/2009Natur.462...71H/doi:10.1038/nature08525">Ho &amp; Heinke (2009)</a>), courtesy of W.C.G. Ho for NICER modeling efforts. A fully-ionized hydrogen atmosphere was used in <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2019ApJ...887L..21R/abstract">Riley et al. (2019)</a>; also see <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2021ApJ...914L..15B/abstract">Bogdanov et al. (2021)</a> and <a class="reference external" href="https://ui.adsabs.harvard.edu/abs/2021ApJ...918L..27R/abstract">Riley et al.
(2021)</a>.</p>
<p>We now instantiate hot region objects. We can find the required and optional parameter names in the class docstring:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.HotRegion#? # uncomment to query
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
xpsi.HotRegion.HotRegion
</pre></div></div>
</div>
<p>The names can also be found as class attributes as follows:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.HotRegion.required_names
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[&#39;super_colatitude&#39;,
 &#39;super_radius&#39;,
 &#39;phase_shift&#39;,
 &#39;super_temperature (if no custom specification)&#39;]
</pre></div></div>
</div>
<p>The condition <em>if no custom specification</em> means that this name is required if we do not supply custom parameters for the radiation field in the superseding member of the hot region. If we supply custom parameters, we also need to subclass <code class="docutils literal notranslate"><span class="pre">xpsi.HotRegion</span></code> and overwrite the <code class="docutils literal notranslate"><span class="pre">__compute_cellParamVecs</span></code> method to handle our parameters.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.HotRegion.optional_names
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[&#39;omit_colatitude&#39;,
 &#39;omit_radius&#39;,
 &#39;omit_azimuth&#39;,
 &#39;cede_colatitude&#39;,
 &#39;cede_radius&#39;,
 &#39;cede_azimuth&#39;,
 &#39;cede_temperature&#39;]
</pre></div></div>
</div>
<p>For the purpose of illustration, we <em>tie</em> the temperatures of the hot regions together: <em>this is where the model deviates from the examples directory as alluded to in the preamble of this tutorial</em>. There is more than one way to achieve this, but we will use the most powerful approach.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>bounds = dict(super_colatitude = (None, None),
              super_radius = (None, None),
              phase_shift = (-0.25, 0.75),
              super_temperature = (None, None))

# a simple circular, simply-connected spot
primary = xpsi.HotRegion(bounds=bounds,
                            values={}, # no initial values and no derived/fixed
                            symmetry=True,
                            omit=False,
                            cede=False,
                            concentric=False,
                            sqrt_num_cells=32,
                            min_sqrt_num_cells=10,
                            max_sqrt_num_cells=64,
                            num_leaves=100,
                            num_rays=200,
                            atm_ext=&quot;BB&quot;,#default blackbody, other options: &quot;Num4D&quot; or &quot;user&quot;
                            prefix=&#39;p&#39;) # unique prefix needed because &gt;1 instance
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;super_colatitude&#34; with bounds [0.000e+00, 3.142e+00].
    &gt; The colatitude of the centre of the superseding region [radians].
Creating parameter:
    &gt; Named &#34;super_radius&#34; with bounds [0.000e+00, 1.571e+00].
    &gt; The angular radius of the (circular) superseding region [radians].
Creating parameter:
    &gt; Named &#34;phase_shift&#34; with bounds [-2.500e-01, 7.500e-01].
    &gt; The phase of the hot region, a periodic parameter [cycles].
Creating parameter:
    &gt; Named &#34;super_temperature&#34; with bounds [3.000e+00, 7.600e+00].
    &gt; log10(superseding region effective temperature [K]).
</pre></div></div>
</div>
<p>Note that since the atmospheric local-comoving-frame effective temperature is uniform everywhere within the hot region boundaries, we can use the default value of the <code class="docutils literal notranslate"><span class="pre">symmetry</span></code> keyword, <code class="docutils literal notranslate"><span class="pre">True</span></code>. All other arguments determine the numerical resolution, and have defaults which have been (somewhat arbitrarily) chosen to be result in a likelihood evaluation time of <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> s.</p>
<p>Let’s take a look at the <code class="docutils literal notranslate"><span class="pre">xpsi.Derive</span></code> docstring for guidance:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.Derive#? # uncomment to query
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
xpsi.Parameter.Derive
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class derive(xpsi.Derive):
    def __init__(self):
        &quot;&quot;&quot;
        We can pass a reference to the primary here instead
        and store it as an attribute if there is risk of
        the global variable changing.

        This callable can for this simple case also be
        achieved merely with a function instead of a magic
        method associated with a class.
        &quot;&quot;&quot;
        pass

    def __call__(self, boundto, caller = None):
        # one way to get the required reference
        global primary # unnecessary, but for clarity
        return primary[&#39;super_temperature&#39;] - 0.2

bounds[&#39;super_temperature&#39;] = None # declare fixed/derived variable

secondary = xpsi.HotRegion(bounds=bounds, # can otherwise use same bounds
                              values={&#39;super_temperature&#39;: derive()}, # create a callable value
                              symmetry=True,
                              omit=False,
                              cede=False,
                              concentric=False,
                              sqrt_num_cells=32,
                              min_sqrt_num_cells=10,
                              max_sqrt_num_cells=100,
                              num_leaves=100,
                              num_rays=200,
                              is_antiphased=True,
                              atm_ext=&quot;BB&quot;,
                              prefix=&#39;s&#39;) # unique prefix needed because &gt;1 instance
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;super_colatitude&#34; with bounds [0.000e+00, 3.142e+00].
    &gt; The colatitude of the centre of the superseding region [radians].
Creating parameter:
    &gt; Named &#34;super_radius&#34; with bounds [0.000e+00, 1.571e+00].
    &gt; The angular radius of the (circular) superseding region [radians].
Creating parameter:
    &gt; Named &#34;phase_shift&#34; with bounds [-2.500e-01, 7.500e-01].
    &gt; The phase of the hot region, a periodic parameter [cycles].
Creating parameter:
    &gt; Named &#34;super_temperature&#34; that is derived from ulterior variables.
    &gt; log10(superseding region effective temperature [K]).
</pre></div></div>
</div>
<p>The description <em>derived from ulterior variables</em> means that when we lookup the value, it is calculated dynamically from the values of other (ulterior) model parameters. We clearly expect the temperature of the secondary hot region to behave in this way. A few other varibles do to because of keyword arguments passed upon instantiation of the hot regions. For example, the colatitude of the <em>zero-radii</em> omission and ceding regions (<code class="docutils literal notranslate"><span class="pre">omit=False</span></code> and <code class="docutils literal notranslate"><span class="pre">cede=False</span></code>) are equivalent to the
colatitude of the centre of the superseding region. The azimuths are <em>relative</em> to the superseding region, and are thus listed as being <em>fixed</em> at zero azimuthal separation. If one of <code class="docutils literal notranslate"><span class="pre">omit</span></code> or <code class="docutils literal notranslate"><span class="pre">cede</span></code> was <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">concentric=True</span></code>, a similar setup is performed, but with the radius of <code class="docutils literal notranslate"><span class="pre">omit</span></code> or <code class="docutils literal notranslate"><span class="pre">cede</span></code> being free, fixed (at finite value, but zero achieves the same as <code class="docutils literal notranslate"><span class="pre">False</span></code> for both <code class="docutils literal notranslate"><span class="pre">omit</span></code> and <code class="docutils literal notranslate"><span class="pre">cede</span></code> keyword arguments), or derived.</p>
<p>We now need to encapsulate the hot region instances in a container with properties expected by the <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> class.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from xpsi import HotRegions

hot = HotRegions((primary, secondary))
</pre></div>
</div>
</div>
<p>Let’s check out the hot regions:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>hot.objects[0] # &#39;p&#39;
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Free parameters
---------------
p__phase_shift: The phase of the hot region, a periodic parameter [cycles].
p__super_colatitude: The colatitude of the centre of the superseding region [radians].
p__super_radius: The angular radius of the (circular) superseding region [radians].
p__super_temperature: log10(superseding region effective temperature [K]).

Derived/fixed parameters
------------------------
p__cede_colatitude: The colatitude of the centre of the ceding region [radians].
p__cede_radius: The angular radius of the (circular) ceding region [radians].
p__cede_azimuth: The azimuth of the centre of the ceding region relative to the
centre of the superseding region [radians].
p__omit_colatitude: The colatitude of the centre of the omission region [radians].
p__omit_radius: The angular radius of the (circular) omission region [radians].
p__omit_azimuth: The azimuth of the centre of the omission region relative to the
centre of the superseding region [radians].
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>hot.objects[1] # &#39;s&#39;
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Free parameters
---------------
s__phase_shift: The phase of the hot region, a periodic parameter [cycles].
s__super_colatitude: The colatitude of the centre of the superseding region [radians].
s__super_radius: The angular radius of the (circular) superseding region [radians].

Derived/fixed parameters
------------------------
s__super_temperature: log10(superseding region effective temperature [K]).
s__cede_colatitude: The colatitude of the centre of the ceding region [radians].
s__cede_radius: The angular radius of the (circular) ceding region [radians].
s__cede_azimuth: The azimuth of the centre of the ceding region relative to the
centre of the superseding region [radians].
s__omit_colatitude: The colatitude of the centre of the omission region [radians].
s__omit_radius: The angular radius of the (circular) omission region [radians].
s__omit_azimuth: The azimuth of the centre of the omission region relative to the
centre of the superseding region [radians].
</pre></div></div>
</div>
<p>A list of names, with the prefix, can also be accessed as follows:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>h = hot.objects[0]
h.names
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[&#39;p__phase_shift&#39;,
 &#39;p__super_colatitude&#39;,
 &#39;p__super_radius&#39;,
 &#39;p__super_temperature&#39;,
 &#39;p__cede_colatitude&#39;,
 &#39;p__cede_radius&#39;,
 &#39;p__cede_azimuth&#39;,
 &#39;p__omit_colatitude&#39;,
 &#39;p__omit_radius&#39;,
 &#39;p__omit_azimuth&#39;]
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>h.prefix
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&#39;p&#39;
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>h.get_param(&#39;phase_shift&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The phase of the hot region, a periodic parameter [cycles]
</pre></div></div>
</div>
<p>Let’s set a value for the temperature of the primary hot region:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>hot[&#39;p__super_temperature&#39;] = 6.0 # equivalent to ``primary[&#39;super_temperature&#39;] = 6.0``
</pre></div>
</div>
</div>
<p>Now let’s lookup the temperature of the secondary:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>secondary[&#39;super_temperature&#39;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
5.8
</pre></div></div>
</div>
<p>No value was set explicitly for this secondary temperature: it is looked up dynamically from that of the primary hot region.</p>
<p>Note that the following access will <em>not</em> work:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># hot[&#39;s__super_temperature&#39;]
</pre></div>
</div>
</div>
<p>The reason for this is because the temperature of the secondary hot region is a <em>fixed/derived</em> variable. Only <em>free</em> model parameters are merged into larger spaces. A fixed/derived variable needs to be accessed via the subspace that directly encapsulates a reference to it.</p>
<p>We can now instantitate the photosphere (assuming a blackbody atmosphere, see <a class="reference external" href="https://github.com/xpsi-group/xpsi/tree/main/examples/examples_modeling_tutorial/TestRun_Num.py">https://github.com/xpsi-group/xpsi/tree/main/examples/examples_modeling_tutorial/TestRun_Num.py</a> for an example when using numerical atmosphere):</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class CustomPhotosphere(xpsi.Photosphere):
    &quot;&quot;&quot; Implement method for imaging.&quot;&quot;&quot;

    @property
    def global_variables(self):

        return np.array([self[&#39;p__super_colatitude&#39;],
                          self[&#39;p__phase_shift&#39;] * 2.0 * math.pi,
                          self[&#39;p__super_radius&#39;],
                          0.0, #self[&#39;p__cede_colatitude&#39;],
                          0.0, #self[&#39;p__phase_shift&#39;] * 2.0 * math.pi - self[&#39;p__cede_azimuth&#39;],
                          0.0, #self[&#39;p__cede_radius&#39;],
                          self[&#39;s__super_colatitude&#39;],
                          (self[&#39;s__phase_shift&#39;] + 0.5) * 2.0 * math.pi,
                          self[&#39;s__super_radius&#39;],
                          0.0, #self[&#39;s__cede_colatitude&#39;],
                          0.0, #(self[&#39;s__phase_shift&#39;] + 0.5) * 2.0 * math.pi - self[&#39;s__cede_azimuth&#39;],
                          0.0, #self[&#39;s__cede_radius&#39;],
                          self[&#39;p__super_temperature&#39;],
                          0.0, #self[&#39;p__cede_temperature&#39;],
                          self.hot.objects[1][&#39;s__super_temperature&#39;],
                          0.0]) #self[&#39;s__cede_temperature&#39;]])
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[40]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>photosphere = CustomPhotosphere(hot = hot, elsewhere = None,
                                values=dict(mode_frequency = spacetime[&#39;frequency&#39;]))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;mode_frequency&#34; with fixed value 3.000e+02.
    &gt; Coordinate frequency of the mode of radiative asymmetry in the
photosphere that is assumed to generate the pulsed signal [Hz].
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>photosphere[&#39;mode_frequency&#39;] == spacetime[&#39;frequency&#39;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p>Note that generally the <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> instance must have a prefix that matches a prefix given to a <code class="docutils literal notranslate"><span class="pre">Signal</span></code> instance to ensure the user achieves what they intend for likelihood evaluation; when the model defines multiple data subsets and thus multiple <a class="reference internal" href="signal.html#xpsi.Signal.Signal"><span class="std std-ref">Signal</span></a> instances, tagging the objects in this manner is a safety guard (in particular against inadvertently wasting compute resources sampling a distribution conditional on an unintended model). If there is
one <code class="docutils literal notranslate"><span class="pre">Photosphere</span></code> and one <code class="docutils literal notranslate"><span class="pre">Signal</span></code> object, the prefixes can simply be none because there is no potential ambiguity.</p>
<p>We do not model the surface radiation field <em>elsewhere</em>, and we thus leave the <code class="docutils literal notranslate"><span class="pre">elsewhere</span></code> keyword as <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default). <em>Elsewhere</em> means on the surface, exterior to radiating hot regions that are typically expected to span a smaller angular extent; in the current version, the radiation from <em>elsewhere</em>, if explicitly computed is assumed to be time-invariant supposing the hot regions were not present. To account for radiation from <em>elsewhere</em>, a time-invariant signal is first computed,
meaning an axisymmetric surface local-comoving-frame radiation field is assumed. The time-dependent signals from the hot regions are then computed, and modified by subtracting the specific intensity that would otherwise be generated by the surface local-comoving-frame radiation field from <em>elsewhere</em> (i.e., in place of the hot regions).</p>
</section>
<section id="Star">
<h4>Star<a class="headerlink" href="#Star" title="Link to this heading"></a></h4>
<p>We can now combine the ambient spacetime, <code class="docutils literal notranslate"><span class="pre">spacetime</span></code>, and the embedded photosphere, <code class="docutils literal notranslate"><span class="pre">photosphere</span></code>, into a model star represented by an instance of <a class="reference internal" href="star.html#xpsi.Star.Star"><span class="std std-ref">Star</span></a>. We do not need to extend this class, so we can simply construct and instantiate a star as follows:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[42]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>star = xpsi.Star(spacetime = spacetime, photospheres = photosphere)
</pre></div>
</div>
</div>
<p>Let’s check out the star object, which merged parameter subspaces associated with objects lower in the hierarchy:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[43]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>star
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[43]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Free parameters
---------------
mass: Gravitational mass [solar masses].
radius: Coordinate equatorial radius [km].
distance: Earth distance [kpc].
cos_inclination: Cosine of Earth inclination to rotation axis.
p__phase_shift: The phase of the hot region, a periodic parameter [cycles].
p__super_colatitude: The colatitude of the centre of the superseding region [radians].
p__super_radius: The angular radius of the (circular) superseding region [radians].
p__super_temperature: log10(superseding region effective temperature [K]).
s__phase_shift: The phase of the hot region, a periodic parameter [cycles].
s__super_colatitude: The colatitude of the centre of the superseding region [radians].
s__super_radius: The angular radius of the (circular) superseding region [radians].
</pre></div></div>
</div>
<p>Note that only the free parameters are merged into a subspace higher in the object hierarchy. The reason for this is that there is not a clear and common pattern (at present) for accessing fixed/derived variables outside of the primary subspace to which they belong. If you try hard enough, of course, you can still get at them.</p>
</section>
</section>
<section id="A-callable-likelihood-object">
<h3>A callable likelihood object<a class="headerlink" href="#A-callable-likelihood-object" title="Link to this heading"></a></h3>
<p>Given the objects constructed above and the relevant pre-compiled low-level code, we can now construct and instantiate a <em>callable</em> likelihood object. We do not need extend (via inheritance) the <a class="reference internal" href="likelihood.html#xpsi.Likelihood.Likelihood"><span class="std std-ref">Likelihood</span></a> class found the source code: this class simply combines all of the model objects defined above, performs some automatic operations given the properties of the those objects, and facilitates communication of those objects when it recieves a call
to evaluate the likelihood.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[44]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood = xpsi.Likelihood(star = star, signals = signal,
                             num_energies=128,
                             threads=1,
                             externally_updated=False)
</pre></div>
</div>
</div>
<p>Let’s retrieve the total number of free model parameters merged into the full parameter space:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Free parameters
---------------
mass: Gravitational mass [solar masses].
radius: Coordinate equatorial radius [km].
distance: Earth distance [kpc].
cos_inclination: Cosine of Earth inclination to rotation axis.
p__phase_shift: The phase of the hot region, a periodic parameter [cycles].
p__super_colatitude: The colatitude of the centre of the superseding region [radians].
p__super_radius: The angular radius of the (circular) superseding region [radians].
p__super_temperature: log10(superseding region effective temperature [K]).
s__phase_shift: The phase of the hot region, a periodic parameter [cycles].
s__super_colatitude: The colatitude of the centre of the superseding region [radians].
s__super_radius: The angular radius of the (circular) superseding region [radians].
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[46]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>len(likelihood)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[46]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
11
</pre></div></div>
</div>
<p><strong>Note that if you want to modify the definition of the model parameter space you should restart the process of constructing a</strong> <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> <strong>object, instead of manipulating existing objects, for ultimate safety.</strong> (You can also restart the kernel although if this is required it is a bug.)</p>
<p>Let’s call the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object with the true model parameter values that we injected to generate the synthetic data rendered above, omitting background parameters. Note that you can switch the phase interpolant invoked from GSL by:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.set_phase_interpolant(&#39;Akima&#39;)
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[48]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>p = [1.4,
     12.5,
     0.2,
     math.cos(1.25),
     0.0,
     1.0,
     0.075,
     6.2,
     0.025,
     math.pi - 1.0,
     0.2]

likelihood.clear_cache()
t = time.time()
# source code changes since model was applied, so let&#39;s be a
# bit lenient when checking the likelihood function
likelihood.check(None, [-2.6883527522e+04], 1.0e-6,
                 physical_points=[p])

print(&#39;time = %.3f s&#39; % (time.time() - t))

# Other interpolants that can be tried:
# &gt; xpsi.set_phase_interpolant(&#39;Steffen&#39;)
# &gt; xpsi.set_phase_interpolant(&#39;Cubic&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Checking likelihood and prior evaluation before commencing sampling...
Not using ``allclose`` function from NumPy.
Using fallback implementation instead.
Checking closeness of likelihood arrays:
-2.6883527522e+04 | -2.6883527522e+04 .....
Closeness evaluated.
Log-likelihood value checks passed on root process.
Checks passed.
time = 0.379 s
</pre></div></div>
</div>
<p>If the secondary temperature was free, we would extend the vector <code class="docutils literal notranslate"><span class="pre">p</span></code> by one element, passing the injected value of <code class="docutils literal notranslate"><span class="pre">6.0</span></code>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[49]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>secondary[&#39;super_temperature&#39;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[49]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
6.0
</pre></div></div>
</div>
<p>External sampling software will interact with a <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object in this way. That is, it will pass some ordered container of parameter values: a vector. However, this vector will be ignored if the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> instance is told it can safely assume all parameters have been updated <em>externally</em>, meaning before the call is placed to <code class="docutils literal notranslate"><span class="pre">likelihood.__call__()</span></code>. This external update will typically happen during <em>nested sampling</em> when a call is placed to a <code class="docutils literal notranslate"><span class="pre">prior</span></code> object to inverse sample
from the joint prior distribution. Our <code class="docutils literal notranslate"><span class="pre">prior</span></code> object can interact with our <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object outside of a sampling process, and thus we can encapsulate a reference to the parameter space in the <code class="docutils literal notranslate"><span class="pre">prior</span></code> instance and simply update the parameter values using easier handles (via <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> magic) to conclude an inverse sampled procedure.</p>
</section>
<section id="Inspecting-functionality">
<h3>Inspecting functionality<a class="headerlink" href="#Inspecting-functionality" title="Link to this heading"></a></h3>
<p>Calling the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object also modified the <code class="docutils literal notranslate"><span class="pre">signals</span></code> property of the <code class="docutils literal notranslate"><span class="pre">photosphere</span></code> object.</p>
<p>The 1D profile in <code class="docutils literal notranslate"><span class="pre">signals</span></code> or <code class="docutils literal notranslate"><span class="pre">photosphere</span></code> are obtained by summing the count-rate over output instrument channels. This is done inside the <code class="docutils literal notranslate"><span class="pre">plot_1d_pulse</span></code> method. The <code class="docutils literal notranslate"><span class="pre">photosphere</span></code> object does not contain the value of the <code class="docutils literal notranslate"><span class="pre">phase</span></code> so we use the ones in <code class="docutils literal notranslate"><span class="pre">signal</span></code> by setting <code class="docutils literal notranslate"><span class="pre">photosphere_phases=signal.phases</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[50]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood(p, reinitialise=False)

XpsiPlot.plot_1d_pulse(signal=signal,
                       photosphere=photosphere,
                       photosphere_phases=signal.phases)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_133_0.png" src="_images/Modeling_133_0.png" />
</div>
</div>
<p>The pulse-profiles with markers are the signals incident on the telescope, before operating on them with the response model. The markers, linearly spaced in phase, denote the phase resolution.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object calls the <code class="docutils literal notranslate"><span class="pre">star.update</span></code> method which in-turn calls the <code class="docutils literal notranslate"><span class="pre">photosphere.embed</span></code> method. The <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object then calls the <code class="docutils literal notranslate"><span class="pre">photosphere.integrate</span></code> method, passing the energies stored as the property <code class="docutils literal notranslate"><span class="pre">signal.energies</span></code>. We can do this manually if we wish to integrate signals but not calculate likelihoods. Here we sum over incident specific photon flux pulses as an approximation to integrating over energy. Note that we do not change the <code class="docutils literal notranslate"><span class="pre">signal.signals</span></code> traced
by the solid curves without markers.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[51]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood[&#39;cos_inclination&#39;] = math.cos(1.0)

likelihood.externally_updated = True # declare safe to assume updates performed before call
xpsi.ParameterSubspace.__call__(likelihood) # no vector supplied
star.update()
photosphere.integrate(energies=signal.energies, threads=1)

XpsiPlot.plot_1d_pulse(signal=signal,
                       photosphere=photosphere,
                       photosphere_phases=signal.phases)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_136_0.png" src="_images/Modeling_136_0.png" />
</div>
</div>
<p>Notice the solid pulses without markers are unchanged from the plot a few cells above, and can be used to guide the eye to the effect of a change in Earth inclination.</p>
<p>Below we print crude representations of the cell meshes spanning each hot region. The elements of a mesh cell-area array which are finite are not all identical: at the boundary of a hot region the proper area elements are smaller because of partial coverage by radiating material. The sum of all finite proper areas effectively equals the total proper area within a hot-region boundary.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[52]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>XpsiPlot.plot_meshes(regions=hot.objects)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Plotting the meshes for 2 regions, with 1 temperatures
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_139_1.png" src="_images/Modeling_139_1.png" />
</div>
</div>
<p>We can also use projection tool to visualize the geometry of the neutron star hot regions (see the separate documenation page for more information about the tool):</p>
<p>Note that the lowest colatitude row is at zero on the y-axis.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[53]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from xpsi.utilities import ProjectionTool
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[54]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ProjectionTool.plot_projection_general((likelihood),&quot;ST&quot;,&quot;I&quot;,&quot;NP&quot;)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
YOU ARE USING 1 HOT SPOT MODEL
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[54]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;Axes: &gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_143_2.png" src="_images/Modeling_143_2.png" />
</div>
</div>
<p>Let’s compute the incident specific flux signal normalised to the maximum and plot a pulse in two dimensions.</p>
<p>Note that if want to obtain the specific flux in units of photons/cm<span class="math notranslate nohighlight">\(^{2}\)</span>/s/keV instead, the output of <code class="docutils literal notranslate"><span class="pre">photosphere.signal</span></code> needs to be divided by distance squared, where distance is measured in meters.</p>
<p>Also note that we can interpolate the signal in phase as follows.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[55]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from xpsi.tools import phase_interpolator

# Interpolation in phase with 500 phase bins
new_phases = np.linspace(0.0, 1, 500)

# Interpolating and summing spot1 (in photosphere.signal[0]) and spot2 (in photosphere.signal[1])
# with their respective signal phase shifts.

# SPOT 1 + SPOT 2
signal_photosphere = phase_interpolator(new_phases, signal.phases[0], photosphere.signal[0][0], signal.shifts[0]) +\
                     phase_interpolator(new_phases, signal.phases[0], photosphere.signal[1][0], signal.shifts[1])

XpsiPlot.plot_2d_pulse(signal_photosphere,
                       x=new_phases,
                       y=signal.energies,
                       rotations=5,
                       ylabel=r&#39;Energy (keV)&#39;,
                       cbar_label=r&#39;Signal (normalized by maximum)&#39;,
                       yticks=[0.2, 0.5, 1.0, 2.0],
                       normalized=True,
                      )
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_145_0.png" src="_images/Modeling_145_0.png" />
</div>
</div>
<p>The count rate in each channel:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[56]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>new_phases = np.linspace(0.0, 1, 500)

# Interpolating and summing spot1 (in signal.signal[0]) and spot2 (in signal.signal[1])
# with their respective signal phase shifts.

# SPOT 1 + SPOT 2
signal_signal = phase_interpolator(new_phases, signal.phases[0], signal.signals[0], signal.shifts[0]) + \
                phase_interpolator(new_phases, signal.phases[0], signal.signals[1], signal.shifts[1])


XpsiPlot.plot_2d_pulse(signal_signal,
                       x=new_phases,
                       y=NICER.channels,
                       rotations=5,
                       ylabel=r&#39;Channels&#39;,
                       cbar_label=&#39;Counts (normalized by maximum)&#39;,
                       yticks=[20,50,100,200],
                       normalized=True,
                      )
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_147_0.png" src="_images/Modeling_147_0.png" />
</div>
</div>
<p>Now we increase the phase resolution, and plot a single rotational pulse:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[57]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for obj in hot.objects:
    obj.set_phases(num_leaves = 1024)
# the current relationship between objects requires that we reinitialise
# if we wish to automatically communicate the updated settings between objects
p[3] = math.cos(1.0) # set inclination
_ = likelihood(p, reinitialise = True)
</pre></div>
</div>
</div>
<p>Note that reinitialisation also returned the following to default:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[58]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.externally_updated
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[58]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
False
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[59]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>new_phases = np.linspace(0.0, 1, 500)

# SPOT 1 + SPOT 2
signal_signal = phase_interpolator(new_phases, signal.phases[0], signal.signals[0], signal.shifts[0]) + \
                phase_interpolator(new_phases, signal.phases[0], signal.signals[1], signal.shifts[1])

XpsiPlot.plot_2d_pulse(signal_signal,
                       x=new_phases,
                       y=NICER.channels,
                       rotations=1,
                       ylabel=r&#39;Channels&#39;,
                       cbar_label=&#39;Counts (normalized by maximum)&#39;,
                       yticks=[20,50,100,200],
                       normalized=True,
                      )
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_152_0.png" src="_images/Modeling_152_0.png" />
</div>
</div>
<p>Let’s iterate over a monotonically increasing set of values of the hot-region angular radius. Note that we use the keyword <code class="docutils literal notranslate"><span class="pre">threads</span></code> to directly instruct the low-level routines how many OpenMP threads to spawn to accelerate the computation. Usually the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object instructs the low-level routines how many threads to spawn, based on it’s <code class="docutils literal notranslate"><span class="pre">thread</span></code> property:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[60]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.threads
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[60]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
1
</pre></div></div>
</div>
<p>Given that we are not currently using the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object as a callback function passed to posterior sampling software (which parallelises efficiently using MPI), we can safely spawn additional OpenMP threads for signal integration; if likelihood evaluations are parallelised in an MPI environment on the other hand, one risks <em>losing</em> efficiency by spawning OpenMP threads for likelihood evaluation.</p>
<p>For objects that derive from <code class="docutils literal notranslate"><span class="pre">ParameterSubspace</span></code> we can get the current parameter vector in several ways:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[61]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>star()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[61]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[1.4,
 12.5,
 0.2,
 0.5403023058681398,
 0.0,
 1.0,
 0.075,
 6.2,
 0.025,
 2.141592653589793,
 0.2]
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[62]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>star() == star.vector # possible shortcut to save some characters
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[62]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Likelihood</span></code> subclass overrides the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> dunder, however, so we have to access it in the following ways:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[63]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>super(xpsi.Likelihood, likelihood).__call__() == likelihood.vector
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[63]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p>Note that we did not define any other parameters other than those associated with the <code class="docutils literal notranslate"><span class="pre">star</span></code>, and thus:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>len(likelihood) == len(star)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p>Finally, let’s play with some geometric parameters:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[65]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure(figsize=(7,7))
ax = fig.add_subplot(111)
ax.set_ylabel(&#39;photons/cm$^2$/s/keV (normalised by maxima)&#39;)
ax.set_xlabel(&#39;Phase [cycles]&#39;)

for obj in hot.objects:
    obj.set_phases(num_leaves = 256)

# let&#39;s play with the angular radius of the primary hot region
angular_radii = np.linspace(0.01, 1.0, 10)

likelihood.externally_updated = True

likelihood[&#39;cos_inclination&#39;] = math.cos(1.25)

for angular_radius in angular_radii:
    likelihood[&#39;p__super_radius&#39;] = angular_radius # play time
    star.update()
    photosphere.integrate(energies=signal.energies, threads=3)
    temp = np.sum(photosphere.signal[0][0] + photosphere.signal[1][0], axis=0)
    _ = ax.plot(hot.phases_in_cycles[0], temp/np.max(temp), &#39;k-&#39;, lw=0.5)

likelihood[&#39;cos_inclination&#39;] = math.cos(1.0)

for angular_radius in angular_radii:
    likelihood[&#39;p__super_radius&#39;] = angular_radius
    star.update()
    photosphere.integrate(energies=signal.energies, threads=3)
    temp = np.sum(photosphere.signal[0][0] + photosphere.signal[1][0], axis=0)
    _ = ax.plot(hot.phases_in_cycles[0], temp/np.max(temp), &#39;r-&#39;, lw=0.5)

likelihood[&#39;cos_inclination&#39;] = math.cos(0.5)

for angular_radius in angular_radii:
    likelihood[&#39;p__super_radius&#39;] = angular_radius
    star.update()
    photosphere.integrate(energies=signal.energies, threads=3)
    temp = np.sum(photosphere.signal[0][0] + photosphere.signal[1][0], axis=0)
    _ = ax.plot(hot.phases_in_cycles[0], temp/np.max(temp), &#39;b-&#39;, lw=0.5)

XpsiPlot.veneer((0.05,0.2), (0.05,0.2), ax)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_164_0.png" src="_images/Modeling_164_0.png" />
</div>
</div>
</section>
</section>
<section id="Prior">
<h2>Prior<a class="headerlink" href="#Prior" title="Link to this heading"></a></h2>
<p>Let us now construct a callable object representing a joint prior density distribution on the space <span class="math notranslate nohighlight">\(\mathbb{R}^{d}\)</span>. We need to extend the base class to implement our distribution, which with respect to some parameters is separable, but for others it is <em>uniform</em> on a joint space, and compactly supported according to non-trivial constraint equations.</p>
<p>As an example gravitational mass and equatorial radius: a joint constraint is imposed to assign zero density to stars which are <em>too</em> compact: the polar radius, in units of the gravitational radius, of the rotationally deformed stellar 2-surface is too small.</p>
<section id="Custom-subclass">
<h3>Custom subclass<a class="headerlink" href="#Custom-subclass" title="Link to this heading"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[66]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from scipy.stats import truncnorm
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[67]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class CustomPrior(xpsi.Prior):
    &quot;&quot;&quot; A custom (joint) prior distribution.

    Source: Fictitious
    Model variant: ST-U
        Two single-temperature, simply-connected circular hot regions with
        unshared parameters.

    &quot;&quot;&quot;

    __derived_names__ = [&#39;compactness&#39;, &#39;phase_separation&#39;,]
    __draws_from_support__ = 3

    def __init__(self):
        &quot;&quot;&quot; Nothing to be done.

        A direct reference to the spacetime object could be put here
        for use in __call__:

        .. code-block::

            self.spacetime = ref

        Instead we get a reference to the spacetime object through the
        a reference to a likelihood object which encapsulates a
        reference to the spacetime object.

        &quot;&quot;&quot;
        super(CustomPrior, self).__init__() # not strictly required if no hyperparameters

    def __call__(self, p = None):
        &quot;&quot;&quot; Evaluate distribution at ``p``.

        :param list p: Model parameter values.

        :returns: Logarithm of the distribution evaluated at ``p``.

        &quot;&quot;&quot;
        temp = super(CustomPrior, self).__call__(p)
        if not np.isfinite(temp):
            return temp

        # based on contemporary EOS theory
        if not self.parameters[&#39;radius&#39;] &lt;= 16.0:
            return -np.inf

        ref = self.parameters.star.spacetime # shortcut

        # limit polar radius to try to exclude deflections &gt;= \pi radians
        # due to oblateness this does not quite eliminate all configurations
        # with deflections &gt;= \pi radians
        R_p = 1.0 + ref.epsilon * (-0.788 + 1.030 * ref.zeta)
        if R_p &lt; 1.76 / ref.R_r_s:
            return -np.inf

        # polar radius at photon sphere for ~static star (static ambient spacetime)
        #if R_p &lt; 1.5 / ref.R_r_s:
        #    return -np.inf

        mu = math.sqrt(-1.0 / (3.0 * ref.epsilon * (-0.788 + 1.030 * ref.zeta)))

        # 2-surface cross-section have a single maximum in |z|
        # i.e., an elliptical surface; minor effect on support, if any,
        # for high spin frequenies
        if mu &lt; 1.0:
            return -np.inf

        ref = self.parameters # redefine shortcut

        # enforce order in hot region colatitude
        if ref[&#39;p__super_colatitude&#39;] &gt; ref[&#39;s__super_colatitude&#39;]:
            return -np.inf

        phi = (ref[&#39;p__phase_shift&#39;] - 0.5 - ref[&#39;s__phase_shift&#39;]) * _2pi

        ang_sep = xpsi.HotRegion.psi(ref[&#39;s__super_colatitude&#39;],
                                     phi,
                                     ref[&#39;p__super_colatitude&#39;])

        # hot regions cannot overlap
        if ang_sep &lt; ref[&#39;p__super_radius&#39;] + ref[&#39;s__super_radius&#39;]:
            return -np.inf

        return 0.0

    def inverse_sample(self, hypercube=None):
        &quot;&quot;&quot; Draw sample uniformly from the distribution via inverse sampling. &quot;&quot;&quot;

        to_cache = self.parameters.vector

        if hypercube is None:
            hypercube = np.random.rand(len(self))

        # the base method is useful, so to avoid writing that code again:
        _ = super(CustomPrior, self).inverse_sample(hypercube)

        ref = self.parameters # shortcut

        idx = ref.index(&#39;distance&#39;)
        ref[&#39;distance&#39;] = truncnorm.ppf(hypercube[idx], -2.0, 7.0, loc=0.3, scale=0.1)

        # flat priors in cosine of hot region centre colatitudes (isotropy)
        # support modified by no-overlap rejection condition
        idx = ref.index(&#39;p__super_colatitude&#39;)
        a, b = ref.get_param(&#39;p__super_colatitude&#39;).bounds
        a = math.cos(a); b = math.cos(b)
        ref[&#39;p__super_colatitude&#39;] = math.acos(b + (a - b) * hypercube[idx])

        idx = ref.index(&#39;s__super_colatitude&#39;)
        a, b = ref.get_param(&#39;s__super_colatitude&#39;).bounds
        a = math.cos(a); b = math.cos(b)
        ref[&#39;s__super_colatitude&#39;] = math.acos(b + (a - b) * hypercube[idx])

        # restore proper cache
        for parameter, cache in zip(ref, to_cache):
            parameter.cached = cache

        # it is important that we return the desired vector because it is
        # automatically written to disk by MultiNest and only by MultiNest
        return self.parameters.vector

    def transform(self, p, **kwargs):
        &quot;&quot;&quot; A transformation for post-processing. &quot;&quot;&quot;

        p = list(p) # copy

        # used ordered names and values
        ref = dict(zip(self.parameters.names, p))

        # compactness ratio M/R_eq
        p += [gravradius(ref[&#39;mass&#39;]) / ref[&#39;radius&#39;]]

        # phase separation between hot regions
        # first some temporary variables:
        if ref[&#39;p__phase_shift&#39;] &lt; 0.0:
            temp_p = ref[&#39;p__phase_shift&#39;] + 1.0
        else:
            temp_p = ref[&#39;p__phase_shift&#39;]

        temp_s = 0.5 + ref[&#39;s__phase_shift&#39;]

        if temp_s &gt; 1.0:
            temp_s = temp_s - 1.0

        # now append:
        if temp_s &gt;= temp_p:
            p += [temp_s - temp_p]
        else:
            p += [1.0 - temp_p + temp_s]

        return p
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[68]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>len(likelihood.vector)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[68]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
11
</pre></div></div>
</div>
<p>We can now construct and instantiate a callable <code class="docutils literal notranslate"><span class="pre">prior</span></code> object, pass it to the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object, which stores a mutual reference to itself in <code class="docutils literal notranslate"><span class="pre">prior</span></code>. Note that if you have hyperparameters defined in the parameter subspace of <code class="docutils literal notranslate"><span class="pre">prior</span></code>, the prior needs to be passed upon instantiation of the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object so that the hyperparameters get merged into the global parameter space; this is not demonstrated in this tutorial.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[69]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>prior = CustomPrior()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
No parameters supplied... empty subspace created.
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[70]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.prior = prior
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[71]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.merge(prior) # if there were hyperparameters, can merge them in
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[72]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.merge(prior) # if there were hyperparameters, can merge them in
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[73]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.externally_updated = True # already set above, but for clarity
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[74]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>prior() # a parameter vector is already stored
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[74]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.0
</pre></div></div>
</div>
<p>We also defined a transform method:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[75]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>prior.transform(p)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[75]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[1.4,
 12.5,
 0.2,
 0.5403023058681398,
 0.0,
 1.0,
 0.075,
 6.2,
 0.025,
 2.141592653589793,
 0.2,
 0.16538201343999998,
 0.525]
</pre></div></div>
</div>
<p>The penultimate entry is the compactness ratio M/R_eq, which should have a familar magnitude. The last entry is the phase separation in cycles.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">prior.inverse_sample()</span></code> method is required by <a class="reference external" href="https://github.com/farhanferoz/MultiNest">MultiNest</a> to uniformly sample from the prior distribution and transform it into a posterior distribution. Let’s call the method, passing a vector of pseudorandom numbers drawn when each is drawn from a uniform distribution on the interval <span class="math notranslate nohighlight">\([0,1)\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[76]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>prior.inverse_sample()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[76]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[2.7076262510297213,
 10.589169013104595,
 0.1456445369136517,
 0.9152783462931748,
 0.22455955750158596,
 1.5833884078131923,
 0.818798126069298,
 4.457565080735115,
 0.7006314853485065,
 2.049354861942553,
 0.8376020115133772]
</pre></div></div>
</div>
<p>In principle, inverse sampling from the prior can be used to initialise the ensemble of walkers evolved by <a class="reference external" href="http://emcee.readthedocs.io/en/latest/">emcee</a>.</p>
</section>
<section id="Density-and-support-checking">
<h3>Density and support checking<a class="headerlink" href="#Density-and-support-checking" title="Link to this heading"></a></h3>
<p>Let’s draw samples from the prior and plot them:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[77]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>samps, _ = prior.draw(int(1e4))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Drawing samples from the joint prior...
Samples drawn.
</pre></div></div>
</div>
<p>Let’s first plot the <span class="math notranslate nohighlight">\((M, R_{\rm eq})\)</span> samples, with the Schwarzschild photon sphere and the radius prior.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[78]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Define the extra lines to plots together with the M-Req samples.
masses = np.linspace(1.0,3.0,100)
R_Schwarz = [3.0*gravradius(masses), masses]
R_Schwarz_label = r&quot;Schwarzschild photon sphere $R_{eq} = 1.5 \times r_s(M)$&quot;
R_prior = [2.0*1.76*gravradius(masses), masses]
R_prior_label = r&quot;$R_{eq} = 1.76 \times r_s(M)$&quot;
extra_plots = [R_Schwarz,R_prior,]
extra_labels = [R_Schwarz_label,R_prior_label,]


ax = XpsiPlot.plot_samps(samps,
                         x_idx=likelihood.index(&#39;radius&#39;), # we can find the index for __getitem__ magic
                         y_idx=likelihood.index(&#39;mass&#39;),
                         xlabel=likelihood.get_param(&#39;radius&#39;).symbol + &#39; [km]&#39;, # can use symbols like so
                         ylabel=r&#39;$M$ [M$_{\odot}$]&#39;, # or manual entry
                         extras=extra_plots,
                         extras_label=extra_labels,
                        )
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_188_0.png" src="_images/Modeling_188_0.png" />
</div>
</div>
<p>Note that the prior support is defined with a constraint that the polar radius <span class="math notranslate nohighlight">\(R_{\rm p}(R_{\rm eq}, M, \Omega)\geq 1.76r_{s}(M)\)</span>, which is why there is a region devoid of samples between the prior support and the dashed line <span class="math notranslate nohighlight">\(R_{\rm eq} = 1.76r_s(M)\)</span>. This condition is not necessary though because as of <code class="docutils literal notranslate"><span class="pre">v0.6</span></code>, X-PSI can include higher-order images, with the secondary and tertiary expected to be entirely sufficient in practice.</p>
<p>Let’s now plot the hot region (circular spot) colatitudes:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[79]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># This diagonal show that we enforce colatitude order to distinguish hot regions as primary and secondary
diagonal = [np.array([0.0,math.pi]),np.array([0.0,math.pi])]
extra_plots = [diagonal, ]
extra_labels = [&#39;diag&#39;]


ax = XpsiPlot.plot_samps(samps,
                         likelihood.index(&#39;p__super_colatitude&#39;),
                         likelihood.index(&#39;s__super_colatitude&#39;),
                         xlabel=r&#39;$\Theta_{p}$ [radians]&#39;,
                         ylabel=r&#39;$\Theta_{s}$ [radians]&#39;,
                         extras=extra_plots,
                         extras_label=extra_labels,
                        )
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_191_0.png" src="_images/Modeling_191_0.png" />
</div>
</div>
<p>Note that the samples, marginalised over other region geometry parameters, are sparser when both hot regions approach the poles because we exclude overlapping configurations from the prior support. This is because the hot regions are by convention defined as disjoint, and cannot merge. If one wanted a more complex hot region, one would not invoke multiple hot regions that are permitted to overlap, but one would instead handle the extra complexity within the <code class="docutils literal notranslate"><span class="pre">HotRegion</span></code> class or a subclass.</p>
<p>Let’s plot the angular radii of the spots:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[80]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = XpsiPlot.plot_samps(samps,
                         likelihood.index(&#39;p__super_radius&#39;),
                         likelihood.index(&#39;s__super_radius&#39;),
                         xlabel=r&#39;$\zeta_{p}$ [radians]&#39;,
                         ylabel=r&#39;$\zeta_{s}$ [radians]&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_194_0.png" src="_images/Modeling_194_0.png" />
</div>
</div>
<p>Note that the prior density is greater for hot regions that subtend smaller solid angles at the centre of the star, which also derives from the non-overlapping criterion for prior support.</p>
<p>Finally, let’s take a look at the phases:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[81]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = XpsiPlot.plot_samps(samps,
                         likelihood.index(&#39;p__phase_shift&#39;),
                         likelihood.index(&#39;s__phase_shift&#39;),
                         xlabel=r&#39;$\phi_{p}$ [cycles]&#39;,
                         ylabel=r&#39;$\phi_{s}$ [cycles]&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_197_0.png" src="_images/Modeling_197_0.png" />
</div>
</div>
<p>Note that again because the hot regions cannot overlap, rarefaction occurs in the vicinity of lines of minimal phase separation. Note that the boundaries are all periodic, so this pattern tesselates. Because we implemented a transformation in our <code class="docutils literal notranslate"><span class="pre">CustomPrior</span></code> subclass, we can actually draw the samples and transform them, which is useful in post-processing contexts. We defined the intervals <code class="docutils literal notranslate"><span class="pre">[-0.25,</span> <span class="pre">0.75]</span></code> for the inverse sampling so that the posterior mode(s) will not be near a boundary.
The nested sampling algorithm can handle periodic boundaries by defining <code class="docutils literal notranslate"><span class="pre">wrapped</span></code> parameters; however, this can be trivially avoided altogether by rough inspection of the phases of the subpulses in the data, which we can see above are at around <span class="math notranslate nohighlight">\(-0.1\)</span> and <span class="math notranslate nohighlight">\(0.4\)</span> given the respective ground truth (injected) phases of <span class="math notranslate nohighlight">\(\phi_{p}=0.0\)</span> and <span class="math notranslate nohighlight">\(\phi_{s}=0.025\)</span>.</p>
<p>Transformations for the purpose of likelihood evaluation must be handled in the <code class="docutils literal notranslate"><span class="pre">inverse_sample</span></code> method of an instance of the <code class="docutils literal notranslate"><span class="pre">Prior</span></code> class, but additional transformations that <em>extend</em> the parameter vector are written in the <code class="docutils literal notranslate"><span class="pre">transform</span></code> method.</p>
<p>If we wanted to transform automatically upon drawing the samples, thereby extending the parameter vectors passed to the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method (so be careful with wrap-around indices when evaluating prior support conditions), we would do the following:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[82]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>samps_plus_transformed, _ = prior.draw(int(1e4), transform=True)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Drawing samples from the joint prior...
Samples drawn.
</pre></div></div>
</div>
<p>We defined a transformation from the hot region centre phases to the phase separation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[83]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = XpsiPlot.plot_samps(samps_plus_transformed,
                         likelihood.index(&#39;p__phase_shift&#39;),
                         likelihood.prior.index(&#39;phase_separation&#39;),
                         xlabel=r&#39;$\phi_{p}$ [cycles]&#39;,
                         ylabel=r&#39;$\Delta\phi$ [cycles]&#39;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_203_0.png" src="_images/Modeling_203_0.png" />
</div>
</div>
<p>We can see the rarefaction occurs for <span class="math notranslate nohighlight">\(\Delta\phi\sim0.0=1.0\)</span>.</p>
<p>The marginal one-dimensional prior distributions are overplotted, by the <a class="reference internal" href="postprocessing.html"><span class="doc">PostProcessing</span></a> module, with the posterior distributions.</p>
<p>It is recommended to carefully inspect joint prior samples for pairs of parameters before commencing a sampling run, especially if there is a non-trivial constraint equation imposed on the prior support.</p>
</section>
</section>
<section id="Sampling-interface">
<h2>Sampling interface<a class="headerlink" href="#Sampling-interface" title="Link to this heading"></a></h2>
<p>We have constructed and instantiated both a callable <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> object and a callable <code class="docutils literal notranslate"><span class="pre">prior</span></code> object. We could proceed, for example, to apply the open-source sampler <a class="reference external" href="https://github.com/JohannesBuchner/PyMultiNest">PyMultiNest</a>, <a class="reference external" href="http://emcee.readthedocs.io/en/latest/">emcee</a>, or <a class="reference external" href="https://johannesbuchner.github.io/UltraNest/">UltraNest</a> to the joint posterior distribution proportional to the product of the (exponentiated) calls to the <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> objects.</p>
<section id="MultiNest">
<h3>MultiNest<a class="headerlink" href="#MultiNest" title="Link to this heading"></a></h3>
<p>We interface with the nested sampler MultiNest in a similar manner, by defining some runtime settings, and then passing those settings together with <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> objects to a wrapper from the <a class="reference internal" href="sample.html"><span class="doc">Sample</span></a> module. We will run the sampler for a specified number (10) of nested replacements (iterations). Note that the output below was actually generated with the temperature of the secondary hot region as a <em>free</em> parameter, resulting in an additional dimension to the model
above.</p>
<p>The environment variable <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> must be set before launching Jupyter as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ export LD_LIBRARY_PATH=&lt;path/to/multinest&gt;/lib
</pre></div>
</div>
<p>Get the parameters that are periodic or <em>wrapped</em> to inform MultiNest of boundary properties:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[84]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>wrapped_params = [0]*len(likelihood)
wrapped_params[likelihood.index(&#39;p__phase_shift&#39;)] = 1
wrapped_params[likelihood.index(&#39;s__phase_shift&#39;)] = 1
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[85]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>os.system(&quot;mkdir -p run&quot;)

runtime_params = {&#39;resume&#39;: False,
                  &#39;importance_nested_sampling&#39;: False,
                  &#39;multimodal&#39;: False,
                  &#39;n_clustering_params&#39;: None,
                  &#39;outputfiles_basename&#39;: &#39;./run/run&#39;, # make ./run directory manually
                  &#39;n_iter_before_update&#39;: 5,
                  &#39;n_live_points&#39;: 50, #100
                  &#39;sampling_efficiency&#39;: 0.8,
                  &#39;const_efficiency_mode&#39;: False,
                  &#39;wrapped_params&#39;: wrapped_params,
                  &#39;evidence_tolerance&#39;: 0.5,
                  &#39;max_iter&#39;: 10, # 10000 # manual termination condition for short test
                  &#39;verbose&#39;: True}

for h in hot.objects:
    h.set_phases(num_leaves = 100)

likelihood.threads = 3
likelihood.reinitialise()
likelihood.clear_cache()

# inform source code that parameter objects updated when inverse sampling
likelihood.externally_updated = True

p = [1.4,
     12.5,
     0.2,
     math.cos(1.25),
     0.0,
     1.0,
     0.075,
     6.2,
     0.025,
     math.pi - 1.0,
     0.2]

# let&#39;s require that checks pass before starting to sample
check_kwargs = dict(hypercube_points = None,
                    physical_points = p, # externally_updated preserved
                    loglikelihood_call_vals = [-2.6883527522e+04], # from above
                    rtol_loglike = 1.0e-6) # choose a tolerance

# note that mutual refs are already stored in the likelihood and prior
# objects to facilitate communication externally of the sampling process
xpsi.Sample.run_multinest(likelihood, prior, check_kwargs, **runtime_params)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Checking likelihood and prior evaluation before commencing sampling...
Not using ``allclose`` function from NumPy.
Using fallback implementation instead.
Checking closeness of likelihood arrays:
-2.6883527522e+04 | -2.6883527522e+04 .....
Closeness evaluated.
Log-likelihood value checks passed on root process.
Checks passed.
Commencing integration...
Estimating fractional hypervolume of the unit hypercube with finite prior density:
Requiring 1E+03 draws from the prior support for Monte Carlo estimation...
Drawing samples from the joint prior...
Samples drawn.
The support occupies an estimated 11.4% of the hypervolume within the unit hypercube...
Fractional hypervolume estimated.
Sampling efficiency set to: 7.0000.
 *****************************************************
 MultiNest v3.12
 Copyright Farhan Feroz &amp; Mike Hobson
 Release Nov 2019

 no. of live points =   50
 dimensionality =   11
 *****************************************************
 Starting MultiNest
 generating live points
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/tmp/ipykernel_5335/2552483892.py:52: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
  eval_marginal_likelihood(self._data.exposure_time,
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
 live points generated, starting sampling
  analysing data from ./run/run.txt ln(ev)=  -6.9572532797281867E+089 +/-                       NaN
 Total Likelihood Evaluations:           62
 Sampling finished. Exiting MultiNest

Integration completed.
</pre></div></div>
</div>
<p>The verbose output of the MultiNest program is by default directed to the host terminal session. Instead of trying to redirect that output to that of the above cell, we simply copy and paste the output from the terminal below. For the purpose of illustration, this output was for a 12-dimensional model variant (but using a longer test run).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*****************************************************
MultiNest v3.11
Copyright Farhan Feroz &amp; Mike Hobson
Release Apr 2018

no. of live points =  100

dimensionality =   12
*****************************************************
Starting MultiNest
generating live points
 live points generated, starting sampling
Acceptance Rate:                        0.724638
Replacements:                                100
Total Samples:                               138
Nested Sampling ln(Z):            **************
Acceptance Rate:                        0.649351
Replacements:                                150
Total Samples:                               231
Nested Sampling ln(Z):            -116670.287917
Acceptance Rate:                        0.569801
Replacements:                                200
Total Samples:                               351
Nested Sampling ln(Z):            -115291.669431
Acceptance Rate:                        0.449640
Replacements:                                250
Total Samples:                               556
Nested Sampling ln(Z):            -108499.449911
Acceptance Rate:                        0.408719
Replacements:                                300
Total Samples:                               734
Nested Sampling ln(Z):             -95430.022790
Acceptance Rate:                        0.367261
Replacements:                                350
Total Samples:                               953
Nested Sampling ln(Z):             -77360.112633
Acceptance Rate:                        0.319744
Replacements:                                400
Total Samples:                              1251
Nested Sampling ln(Z):             -66119.380404
Acceptance Rate:                        0.263930
Replacements:                                450
Total Samples:                              1705
Nested Sampling ln(Z):             -57607.930990
Acceptance Rate:                        0.213675
Replacements:                                500
Total Samples:                              2340
Nested Sampling ln(Z):             -53505.956949
Acceptance Rate:                        0.173119
Replacements:                                550
Total Samples:                              3177
Nested Sampling ln(Z):             -50428.177797
Acceptance Rate:                        0.147893
Replacements:                                600
Total Samples:                              4057
Nested Sampling ln(Z):             -47108.755667
Acceptance Rate:                        0.132653
Replacements:                                650
Total Samples:                              4900
Nested Sampling ln(Z):             -43437.007007
Acceptance Rate:                        0.125381
Replacements:                                700
Total Samples:                              5583
Nested Sampling ln(Z):             -39888.092691
Acceptance Rate:                        0.113533
Replacements:                                750
Total Samples:                              6606
Nested Sampling ln(Z):             -36841.337131
Acceptance Rate:                        0.100251
Replacements:                                800
Total Samples:                              7980
Nested Sampling ln(Z):             -34450.919514
Acceptance Rate:                        0.088450
Replacements:                                850
Total Samples:                              9610
Nested Sampling ln(Z):             -32545.531967
Acceptance Rate:                        0.080121
Replacements:                                900
Total Samples:                             11233
Nested Sampling ln(Z):             -31270.147897
Acceptance Rate:                        0.069674
Replacements:                                950
Total Samples:                             13635
Nested Sampling ln(Z):             -30103.155016
Acceptance Rate:                        0.064201
Replacements:                               1000
Total Samples:                             15576
Nested Sampling ln(Z):             -29365.169148
Acceptance Rate:                        0.058427
Replacements:                               1050
Total Samples:                             17971
Nested Sampling ln(Z):             -28879.280235
 ln(ev)=  -28879.280235090871      +/-                       NaN
 Total Likelihood Evaluations:        17971
 Sampling finished. Exiting MultiNest
</pre></div>
</div>
</section>
<section id="UltraNest">
<h3>UltraNest<a class="headerlink" href="#UltraNest" title="Link to this heading"></a></h3>
<p>Another sampler that can be used as alternative to MultiNest is UltraNest. UltraNest contains many different sampling algorithms, but defaults to the nested sampling Monte Carlo MLFriends algorithm (Buchner, <a class="reference external" href="https://arxiv.org/abs/1407.5459">2014</a>; <a class="reference external" href="https://arxiv.org/abs/1707.04476">2019</a>). This is a type of region sampling similar to MultiNest, however, the way in which the shape and location of the ellipsoids is determined is different.</p>
<p>We interface with the sampler UltraNest is a similar manner as MultiNest: we define some runtime settings, and then pass those settings together with <code class="docutils literal notranslate"><span class="pre">likelihood</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> objects to a wrapper from the <a class="reference internal" href="sample.html"><span class="doc">Sample</span></a> module. Note that the output below is generated with the temperature of the secondary hot region as a <em>free</em> parameter, similarly to the MultiNest example above.</p>
<p>In this example, we will run the sampler with a maximum of a 10 iterations. For a real inference problem, we don’t recommend this. See <a class="reference external" href="https://johannesbuchner.github.io/UltraNest/issues.html#how-should-i-choose-the-number-of-live-points">UltraNest’s FAQ</a> and references therein for more information about choosing sampler settings.</p>
<p>To run UltraNest, we first define the parameters that are periodic or <em>wrapped</em> to inform UltraNest of boundary properties:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[86]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>wrapped_params = [False]*len(likelihood)
wrapped_params[likelihood.index(&#39;p__phase_shift&#39;)] = True
wrapped_params[likelihood.index(&#39;s__phase_shift&#39;)] = True
</pre></div>
</div>
</div>
<p>Next, we define the <code class="docutils literal notranslate"><span class="pre">sampler_params</span></code> which is a dictionary of the keyword arguments passed class <code class="docutils literal notranslate"><span class="pre">Sample.UltranestSampler</span></code> to initialise the sampler. UltraNest uses a reactive nested sampling algorithm, meaning it adapts the number of live points during the run. Therefore, we define a minimum (and maximum) number of live points instead of a fixed number.</p>
<p>Some useful keyword arguments that are not used in this example are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">log_dir</span></code> to specify the directory where the output files are stored. As a default, <code class="docutils literal notranslate"><span class="pre">log_dir='output'</span></code>, so the output will be stored in a folder called <code class="docutils literal notranslate"><span class="pre">output</span></code> in the current directory. Unless otherwise specified, UltraNest will automatically create sub-directories called e.g. <code class="docutils literal notranslate"><span class="pre">run1</span></code> with incrementing numbers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">resume=True</span></code> for if you want to resume a run. As a default, <code class="docutils literal notranslate"><span class="pre">resume=subfolder</span></code> which creates a fresh sub-directory in <code class="docutils literal notranslate"><span class="pre">log_dir</span></code></p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[87]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sampler_params = {&#39;wrapped_params&#39;: wrapped_params}
</pre></div>
</div>
</div>
<p>We then also define the <code class="docutils literal notranslate"><span class="pre">runtime_params</span></code> which is a dictionary of the keyword arguments passed to the <code class="docutils literal notranslate"><span class="pre">Sample.UltranestSampler</span></code> to run the sampler. Next, we can start sampling:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[88]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>runtime_params = {&#39;show_status&#39;:True, # show integration progress as a status line
                &#39;min_num_live_points&#39;:400,
                &#39;max_iters&#39;:10}

# let&#39;s sample!
xpsi.Sample.run_ultranest(likelihood,
                          prior,
                          sampler_params,
                          runtime_params)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating directory for new run output/run8
[ultranest] Sampling 400 live points from prior ...
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/tmp/ipykernel_5335/2552483892.py:52: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
  eval_marginal_likelihood(self._data.exposure_time,
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[ultranest] Widening roots to 749 live points (have 400 already) ...
[ultranest] Sampling 349 live points from prior ...
[ultranest] Widening roots to 1408 live points (have 749 already) ...
[ultranest] Sampling 659 live points from prior ...
[ultranest] Widening roots to 2638 live points (have 1408 already) ...
[ultranest] Sampling 1230 live points from prior ...
[ultranest] Widening roots to 4945 live points (have 2638 already) ...
[ultranest] Sampling 2307 live points from prior ...
[ultranest] Explored until L=-9e+04
[ultranest] Likelihood function evaluations: 4945
[ultranest] Writing samples and results to disk ...
[ultranest] Writing samples and results to disk ... done
[ultranest]   logZ = -9.622e+04 +- 3365
[ultranest] Effective samples strategy satisfied (ESS = 1.0, need &gt;400)
[ultranest] Posterior uncertainty strategy wants to improve: -1099999999999999951824702772428630345474600697127459551981745117036136399002837465482395648.00..-93627.30 (KL: 2579.77+-7964.79 nat, need &lt;0.50 nat)
[ultranest] Evidency uncertainty strategy wants 141 minimum live points (dlogz from 2579.86 to 10544.10, need &lt;0.5)
[ultranest]   logZ error budget: single: inf bs:3365.18 tail:0.69 total:3365.18 required:&lt;0.50
[ultranest] Widening from 1 to 9890 live points before L=-1e+90...
[ultranest] parent value is -inf, so widening roots
[ultranest] Widening roots to 9890 live points (have 4945 already) ...
[ultranest] Sampling 4945 live points from prior ...
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/home/saltuomo/.conda/envs/xpsi_py3/lib/python3.12/site-packages/ultranest/integrator.py:1686: RuntimeWarning: invalid value encountered in divide
  p /= p.sum(axis=0).reshape((1, -1))
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[ultranest] Exploring (in particular: L=-inf..-93627.30) ...
[ultranest] Explored until L=-9e+04
[ultranest] Likelihood function evaluations: 9890
[ultranest] Writing samples and results to disk ...
[ultranest] Writing samples and results to disk ... done
[ultranest] No changes made. Probably the strategy was to explore in the remainder, but it is irrelevant already; try decreasing frac_remain.
[ultranest] done iterating.

logZ = -93636.499 +- 0.835
  single instance: logZ = -93636.499 +- nan
  bootstrapped   : logZ = -97163.847 +- 0.466
  tail           : logZ = +- 0.693
insert order U test : converged: True correlation: inf iterations

    mass                : 1.00000200000000006│           ▇                           │1.78460693355751965    1.23460693355751916 +- 0.00000000000000044
    radius              : 8.926 │                   ▇                   │10.026    9.476 +- 0.000
    distance            : 0.100 │         ▇                             │0.776     0.266 +- 0.000
    cos_inclination     : 0.000001000000000000│           ▇                           │0.784907650282022251    0.234907650282022262 +- 0.000000000000000056
    p__phase_shift      : -0.249998999999999999│        ▇                              │0.459161698743967173    -0.090838301256032844 +- 0.000000000000000028
    p__super_colatitude 0.166080489736599668 +- 0.000000000000000056
    p__super_radius     : 0.000 │    ▇                                  │0.625     0.075 +- 0.000
    p__super_temperature: 5.72681010202611951│                   ▇                   │6.82681010202612093    6.27681010202611933 +- 0.00000000000000089
    s__phase_shift      : -0.250│            ▇                          │0.550     0.000 +- 0.000
    s__super_colatitude 0.390547853904741948 +- 0.000000000000000056
    s__super_radius     : 0.0000015707963267949│  ▇                                    │0.5911570045319668454    0.0411570045319668149 +- 0.0000000000000000069

</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[88]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;xpsi.UltranestSampler.UltranestSampler at 0x74b28b5130e0&gt;
</pre></div></div>
</div>
<p>UltraNest also contains various step sampling algorithms which are generally better for high dimensional problems. In X-PSI, the slice sampling algorithm is implemented as step sampler. To use this, we need to set <code class="docutils literal notranslate"><span class="pre">use_stepsampler=True</span></code> and define a dictionary of keyword arguments passed to <code class="docutils literal notranslate"><span class="pre">Sample.UltranestSampler</span></code> to run the step sampler. The essential parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nsteps</span></code> which define the number of accepted steps until the sample is considered independent</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generate_direction</span></code> to specify the direction of the proposal function. The default is <code class="docutils literal notranslate"><span class="pre">generate_mixture_random_direction</span></code>, which is the one recommended in the UltraNest tutorials. This parameter is not shown in this example.</p></li>
</ul>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[89]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>stepsampler_params = {&#39;nsteps&#39;:10}

xpsi.Sample.run_ultranest(likelihood,
                prior,
                sampler_params,
                runtime_params,
                use_stepsampler=True,
                stepsampler_params=stepsampler_params)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating directory for new run output/run9
[ultranest] Sampling 400 live points from prior ...
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/tmp/ipykernel_5335/2552483892.py:52: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
  eval_marginal_likelihood(self._data.exposure_time,
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[ultranest] Widening roots to 753 live points (have 400 already) ...
[ultranest] Sampling 353 live points from prior ...
[ultranest] Widening roots to 1416 live points (have 753 already) ...
[ultranest] Sampling 663 live points from prior ...
[ultranest] Widening roots to 2660 live points (have 1416 already) ...
[ultranest] Sampling 1244 live points from prior ...
[ultranest] Widening roots to 5001 live points (have 2660 already) ...
[ultranest] Sampling 2341 live points from prior ...
[ultranest] Explored until L=-1e+05
[ultranest] Likelihood function evaluations: 5001
[ultranest] Writing samples and results to disk ...
[ultranest] Writing samples and results to disk ... done
[ultranest]   logZ = -1.085e+05 +- 245.6
[ultranest] Effective samples strategy satisfied (ESS = 1.0, need &gt;400)
[ultranest] Posterior uncertainty strategy wants to improve: -1099999999999999951824702772428630345474600697127459551981745117036136399002837465482395648.00..-108337.48 (KL: 118.02+-810.53 nat, need &lt;0.50 nat)
[ultranest] Evidency uncertainty strategy wants 142 minimum live points (dlogz from 118.30 to 928.08, need &lt;0.5)
[ultranest]   logZ error budget: single: inf bs:245.55 tail:0.69 total:245.56 required:&lt;0.50
[ultranest] Widening from 1 to 10002 live points before L=-1e+90...
[ultranest] parent value is -inf, so widening roots
[ultranest] Widening roots to 10002 live points (have 5001 already) ...
[ultranest] Sampling 5001 live points from prior ...
[ultranest] Exploring (in particular: L=-inf..-108337.48) ...
[ultranest] Explored until L=-1e+05
[ultranest] Likelihood function evaluations: 10002
[ultranest] Writing samples and results to disk ...
[ultranest] Writing samples and results to disk ... done
[ultranest] No changes made. Probably the strategy was to explore in the remainder, but it is irrelevant already; try decreasing frac_remain.
[ultranest] done iterating.

logZ = -102744.156 +- 0.837
  single instance: logZ = -102744.156 +- nan
  bootstrapped   : logZ = -104334.314 +- 0.469
  tail           : logZ = +- 0.693
insert order U test : converged: True correlation: inf iterations
diagnostic unavailable, no recorded steps found

    mass                : 1.00000200000000006│                 ▇                     │1.97897868635998497    1.42897868635998537 +- 0.00000000000000044
    radius              : 7.9118406646718906│                   ▇                   │9.0118406646718920    8.4618406646718931 +- 0.0000000000000018
    distance            : 0.100 │    ▇                                  │0.722     0.172 +- 0.000
    cos_inclination     : 0.00000100000000000│              ▇                        │0.86471246335300345    0.31471246335300329 +- 0.00000000000000011
    p__phase_shift      : -0.250│       ▇                               │0.440     -0.110 +- 0.000
    p__super_colatitude 0.56303960837445488 +- 0.00000000000000011
    p__super_radius     : 0.000 │         ▇                             │0.735     0.185 +- 0.000
    p__super_temperature: 5.46049228887493499│                   ▇                   │6.56049228887493641    6.01049228887493481 +- 0.00000000000000089
    s__phase_shift      : -0.250│          ▇                            │0.493     -0.057 +- 0.000
    s__super_colatitude 1.99833371815393779 +- 0.00000000000000067
    s__super_radius     : 0.000 │         ▇                             │0.716     0.166 +- 0.000

diagnostic unavailable, no recorded steps found
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[89]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;xpsi.UltranestSampler.UltranestSampler at 0x74b29848a870&gt;
</pre></div></div>
</div>
<p>In addition to UltraNest’s standard output files, a .txt file with the default name <code class="docutils literal notranslate"><span class="pre">weighted_post_ultranest_xpsi</span></code> is created when the inference finished. This file can be used for post-processing within X-PSI as usual.</p>
</section>
<section id="Ensemble-MCMC">
<h3>Ensemble MCMC<a class="headerlink" href="#Ensemble-MCMC" title="Link to this heading"></a></h3>
<p>To prove that the objects constructed above can be fed to the <code class="docutils literal notranslate"><span class="pre">emcee</span></code> sampler, let’s run a number of iterations using a single Python process. We will initialise the ensemble by drawing from a multivariate Gaussian with mean vector equal to the ground truth (injected) vector.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[90]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>std = [1.0,
         0.05,
         1.0,
         0.01,
         0.05,
         0.0025,
         0.01,
         0.05,
         0.05,
         0.01,
         0.01]

runtime_params = {&#39;resume&#39;: False,
                  &#39;root_dir&#39;: &#39;./&#39;,
                  &#39;nwalkers&#39;: 50,
                  &#39;nsteps&#39;: 10,
                  &#39;walker_dist_moments&#39;: zip(p, std)} #  if resume then ``None``

for h in hot.objects:
    h.set_phases(num_leaves = 100) # revert to original phase resolution above

likelihood.threads = 3
likelihood.reinitialise() # because we played with the object above

# Use MPI=False for testing purposes
backend = xpsi.Sample.run_emcee(likelihood, prior,
                                MPI=False, **runtime_params)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

Warning: a ``samples.h5`` file exists in ``./``.
Attempting to move ``samples.h5`` to a subdirectory of ``./``.
File archived in subdirectory ``./old_samples``.

Commencing posterior sampling.
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/tmp/ipykernel_5335/2552483892.py:52: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
  eval_marginal_likelihood(self._data.exposure_time,
100%|███████████████████████████████████████████| 10/10 [02:24&lt;00:00, 14.42s/it]
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

Sampling complete.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>

</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[91]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># clean up the docs/source directory
#!rm samples.h5; rm -r old_samples
</pre></div>
</div>
</div>
<p>Note that we could also try initialising the ensemble by inverse sampling the joint prior distribution.</p>
<p>Let’s quickly plot the evolution of the ensemble Markov chains to prove that the sampling process commenced and is behaving in a somewhat reasonable manner:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[92]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>try:
    backend
except NameError:
    import emcee
    backend = emcee.backends.HDFBackend(&#39;samples.h5&#39;)

chain = backend.get_chain()

# These chains plotted were generated using
# v0.2 so the labels here are in a different
# order. The model also had two free
# temperature parameters instead of just one.
# Also, inclination was the parameter, not
# cos(inclination), and the prior was flat
# in inclination, not cos(inclination).
labels = [r&#39;$D$&#39;,
          r&#39;$M$&#39;,
          r&#39;$R_{\rm eq}$&#39;,
          r&#39;$\cos(i)$&#39;,
          r&#39;$\phi_{p}$&#39;,
          r&#39;$\Theta_{p}$&#39;,
          r&#39;$\zeta_{p}$&#39;,
          r&#39;$T_{p}$&#39;,
          r&#39;$\phi_{s}$&#39;
          r&#39;$\Theta_{s}$&#39;,
          r&#39;$\zeta_{s}$&#39;]

fig = plt.figure(figsize=(8,32))

gs = gridspec.GridSpec(12, 1, hspace=0.15)

for i in range(len(labels)):
    ax = plt.subplot(gs[i,0])
    ax.set_ylabel(labels[i])
    for j in range(50):
        plt.plot(chain[:,j,i], &#39;k-&#39;, lw=0.5, alpha=0.5)
    if i &lt; 11:
        ax.tick_params(axis=&#39;x&#39;, labelbottom=False)
        plt.setp(ax.get_yticklabels()[0], visible=False)
        plt.setp(ax.get_yticklabels()[-1], visible=False)
    else: ax.set_xlabel(&#39;Steps&#39;)
    XpsiPlot.veneer((250, 1000), None, ax)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_230_0.png" src="_images/Modeling_230_0.png" />
</div>
</div>
<p>The chains rendered in the documentation were run on a desktop machine in about a day of wall-time. It is visually discernable that the ensemble distribution has not yet evolved to a stationary state: a rigourous application of ensemble MCMC would cover convergence criteria, auto-correlation, and examination of sensitivity to initial conditions and the transition kernel. In fact, based on the analysis with nested sampling on path <code class="docutils literal notranslate"><span class="pre">xpsi/examples/default_background</span></code>, we know that the posterior
mode in the vicinity of the above ensemble is rather non-linear in the space being sampled, so ensemble MCMC may require <em>many</em> steps in order to argue for convergence.</p>
</section>
</section>
<section id="Synthesis">
<h2>Synthesis<a class="headerlink" href="#Synthesis" title="Link to this heading"></a></h2>
<p>In this notebook thus far we have not generated sythetic data. However, we did condition on synthetic data. Below we outline how that data was generated.</p>
<section id="Background">
<h3>Background<a class="headerlink" href="#Background" title="Link to this heading"></a></h3>
<p>The background radiation field incident on the model instrument for the purpose of generating synthetic data was a time-invariant powerlaw spectrum, and was transformed into a count-rate in each output channel using the response matrix for synthetic data generation. We would reproduce this background here by writing a custom subclass as follows.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[93]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class CustomBackground(xpsi.Background):
    &quot;&quot;&quot; The background injected to generate synthetic data. &quot;&quot;&quot;

    def __init__(self, bounds=None, value=None):

        # first the parameters that are fundemental to this class
        doc = &quot;&quot;&quot;
        Powerlaw spectral index.
        &quot;&quot;&quot;
        index = xpsi.Parameter(&#39;powerlaw_index&#39;,
                                strict_bounds = (-3.0, -1.01),
                                bounds = bounds,
                                doc = doc,
                                symbol = r&#39;$\Gamma$&#39;,
                                value = value)

        super(CustomBackground, self).__init__(index)

    def __call__(self, energy_edges, phases):
        &quot;&quot;&quot; Evaluate the incident background field. &quot;&quot;&quot;

        G = self[&#39;powerlaw_index&#39;]

        temp = np.zeros((energy_edges.shape[0] - 1, phases.shape[0]))

        temp[:,0] = (energy_edges[1:]**(G + 1.0) - energy_edges[:-1]**(G + 1.0)) / (G + 1.0)

        for i in range(phases.shape[0]):
            temp[:,i] = temp[:,0]

        self._incident_background = temp
</pre></div>
</div>
</div>
<p>Note that the analytic background is integrated over energy intervals, as required by a <code class="docutils literal notranslate"><span class="pre">Signal</span></code> instance, which would then straightforwardly apply the model instrument response to the background.</p>
<p>We can now construct and instantiate a <code class="docutils literal notranslate"><span class="pre">background</span></code> object. The base clase <code class="docutils literal notranslate"><span class="pre">xpsi.Background</span></code> is inherited from the <a class="reference internal" href="parameterSubspace.html#xpsi.ParameterSubspace.ParameterSubspace"><span class="std std-ref">ParameterSubspace</span></a> ABC. We therefore need to specify the number of background parameters, and define the hard bounds on those parameters; in this case we have only a single parameter, the powerlaw index.</p>
<p>We would then instantiate as follows:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[94]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>background = CustomBackground(bounds=(None, None)) # use strict bounds, but do not fix/derive
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Creating parameter:
    &gt; Named &#34;powerlaw_index&#34; with bounds [-3.000e+00, -1.010e+00].
    &gt; Powerlaw spectral index.
</pre></div></div>
</div>
</section>
<section id="Data-format">
<h3>Data format<a class="headerlink" href="#Data-format" title="Link to this heading"></a></h3>
<p>We are also in need of a simpler data object.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[95]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class SynthesiseData(xpsi.Data):
    &quot;&quot;&quot; Custom data container to enable synthesis. &quot;&quot;&quot;

    def __init__(self, channels, phases, first, last):

        self.channels = channels
        self._phases = phases

        try:
            self._first = int(first)
            self._last = int(last)
        except TypeError:
            raise TypeError(&#39;The first and last channels must be integers.&#39;)
        if self._first &gt;= self._last:
            raise ValueError(&#39;The first channel number must be lower than the &#39;
                             &#39;the last channel number.&#39;)
</pre></div>
</div>
</div>
<p>Instantiate:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[96]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>_data = SynthesiseData(np.arange(20,201), np.linspace(0.0, 1.0, 33), 0, 180)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Setting channels for event data...
Channels set.
</pre></div></div>
</div>
</section>
<section id="Custom-method">
<h3>Custom method<a class="headerlink" href="#Custom-method" title="Link to this heading"></a></h3>
<p>We are in need of a <code class="docutils literal notranslate"><span class="pre">synthesise</span></code> method, which in this implementation wraps an extension module. Let’s check what the extension module offers:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[97]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from xpsi.tools.synthesise import synthesise_given_total_count_number as _synthesise
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[98]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>_synthesise
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[98]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;cyfunction synthesise_given_total_count_number at 0x74b3fc1ad3c0&gt;
</pre></div></div>
</div>
<p>When creating synthetic data, we can fix the random seed for noise by providing it as an input parameter called ‘gsl_seed’. If no input is provided, the seed is based on the clock time.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[99]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def synthesise(self,
               require_source_counts,
               require_background_counts,
               name=&#39;synthetic&#39;,
               directory=&#39;./data&#39;,
               **kwargs):
        &quot;&quot;&quot; Synthesise data set.

        &quot;&quot;&quot;
        self._expected_counts, synthetic, _, _ = _synthesise(self._data.phases,
                                            require_source_counts,
                                            self._signals,
                                            self._phases,
                                            self._shifts,
                                            require_background_counts,
                                            self._background.registered_background,
                                            gsl_seed=0) #seed=0
        try:
            if not os.path.isdir(directory):
                os.mkdir(directory)
        except OSError:
            print(&#39;Cannot create write directory.&#39;)
            raise

        np.savetxt(os.path.join(directory, name+&#39;_realisation.dat&#39;),
                   synthetic,
                   fmt = &#39;%u&#39;)

        self._write(self.expected_counts,
                    filename = os.path.join(directory, name+&#39;_expected_hreadable.dat&#39;),
                    fmt = &#39;%.8e&#39;)

        self._write(synthetic,
                    filename = os.path.join(directory, name+&#39;_realisation_hreadable.dat&#39;),
                    fmt = &#39;%u&#39;)

def _write(self, counts, filename, fmt):
    &quot;&quot;&quot; Write to file in human readable format. &quot;&quot;&quot;

    rows = len(self._data.phases) - 1
    rows *= len(self._data.channels)

    phases = self._data.phases[:-1]
    array = np.zeros((rows, 3))

    for i in range(counts.shape[0]):
        for j in range(counts.shape[1]):
            array[i*len(phases) + j,:] = self._data.channels[i], phases[j], counts[i,j]

    np.savetxt(filename, array, fmt=[&#39;%u&#39;, &#39;%.6f&#39;] + [fmt])
</pre></div>
</div>
</div>
<p>Add unbound methods:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[100]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>CustomSignal.synthesise = synthesise
CustomSignal._write = _write
</pre></div>
</div>
</div>
<p>Instantiate, and reconfigure the likelihood object:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[101]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>signal = CustomSignal(data = _data,
                        instrument = NICER,
                        background = background,
                        interstellar = None,
                        min_channel=20,
                        max_channel=200,
                        prefix=&#39;NICER&#39;)

for h in hot.objects:
    h.set_phases(num_leaves = 100)

likelihood = xpsi.Likelihood(star = star, signals = signal, threads=1)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Trimming event data...
WARNING : There is no counts in data object. This is normal if you are trying to synthesise data.Otherwise something is very wrong and do not continue
Trimming instrument response...
Setting channels for loaded instrument response (sub)matrix...
Channels set.
Instrument response trimmed.
Creating parameter:
    &gt; Named &#34;phase_shift&#34; with fixed value 0.000e+00.
    &gt; The phase shift for the signal, a periodic parameter [cycles].
Warning: No data... can synthesise data but cannot evaluate a likelihood function.
</pre></div></div>
</div>
</section>
<section id="Synthesise">
<h3>Synthesise<a class="headerlink" href="#Synthesise" title="Link to this heading"></a></h3>
<p>Check write path:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[102]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>!pwd
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
/home/saltuomo/xpsi/xpsi_group/xpsi/docs/source
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[103]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[103]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Free parameters
---------------
mass: Gravitational mass [solar masses].
radius: Coordinate equatorial radius [km].
distance: Earth distance [kpc].
cos_inclination: Cosine of Earth inclination to rotation axis.
p__phase_shift: The phase of the hot region, a periodic parameter [cycles].
p__super_colatitude: The colatitude of the centre of the superseding region [radians].
p__super_radius: The angular radius of the (circular) superseding region [radians].
p__super_temperature: log10(superseding region effective temperature [K]).
s__phase_shift: The phase of the hot region, a periodic parameter [cycles].
s__super_colatitude: The colatitude of the centre of the superseding region [radians].
s__super_radius: The angular radius of the (circular) superseding region [radians].
NICER__powerlaw_index: Powerlaw spectral index.
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[104]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>p = [1.4,
     12.5,
     0.2,
     math.cos(1.25),
     0.0,
     1.0,
     0.075,
     6.2,
     0.025,
     math.pi - 1.0,
     0.2,
     -2.0]

NICER_kwargs = dict(require_source_counts=2.0e6,
                     require_background_counts=2.0e6,
                     name=&#39;new_synthetic&#39;,
                     directory=&#39;./data&#39;)

likelihood.synthesise(p, force=True, NICER=NICER_kwargs)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Exposure time: 931991.582544 [s]
Background normalisation: 1.96659848e-05
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[105]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>XpsiPlot.plot_2d_pulse(pulse=np.loadtxt(&#39;data/new_synthetic_realisation.dat&#39;, dtype=np.double),
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Counts&#39;,)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_261_0.png" src="_images/Modeling_261_0.png" />
</div>
</div>
<p>Check we have generated the same count numbers, given the same seed and resolution settings:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[106]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>diff = data.counts - np.loadtxt(&#39;data/new_synthetic_realisation.dat&#39;, dtype=np.double)
(diff != 0.0).any()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[106]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
<p>The output should be <code class="docutils literal notranslate"><span class="pre">False</span></code> if there is no difference in the expectations of the Poisson-distribution random variables. Now however, we have some small differences, because the synthetic data used in this notebook were produced using the non-periodic Steffen spline interpolants (used by default in X-PSI v0.5 and before, and turned on at the end of this tutorial) instead of the Akima Periodic splines phase interpolants from GSL. The aim in swapping to Akima was to increase accuracy near the
signal maxima and minima, whilst potentially sacrificing some accuracy when interpolating a curve that is truncated at zero due to a radiating element going out of visibility, or in the context of an extended radiating region, that region going fully out of visibility.</p>
<p>Let’s plot the difference between the expectations:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[107]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = np.loadtxt(&#39;../../examples/examples_modeling_tutorial/model_data/example_synthetic_expected_hreadable.dat&#39;)
y = np.loadtxt(&#39;data/new_synthetic_expected_hreadable.dat&#39;)

xx = np.zeros(data.counts.shape)
yy = np.zeros(data.counts.shape)

for i in range(xx.shape[0]):
    for j in range(xx.shape[1]):
        xx[i,j] = x[i*32 + j,-1]
        yy[i,j] = y[i*32 + j,-1]
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[108]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>XpsiPlot.plot_2d_pulse(pulse=xx,
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Counts&#39;,)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_267_0.png" src="_images/Modeling_267_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[109]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>XpsiPlot.plot_2d_pulse(pulse=yy-xx,
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Counts&#39;,)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_268_0.png" src="_images/Modeling_268_0.png" />
</div>
</div>
<p>And normalised by the root-variance:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[110]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>_r = (yy-xx)/np.sqrt(yy)

XpsiPlot.plot_2d_pulse(pulse=_r,
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Standardised residuals&#39;,
                       cmap=cm.RdBu,
                       vmin=-np.max(np.fabs(_r)),
                       vmax=np.max(np.fabs(_r)))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_270_0.png" src="_images/Modeling_270_0.png" />
</div>
</div>
<p>The difference between realisations is far larger than one count (which is what might be expected in some cases due to discreteness of the Poisson probability mass function) for many intervals, despite the small change in the expectation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[111]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>XpsiPlot.plot_2d_pulse(pulse=diff,
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Counts&#39;,
                      )
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_272_0.png" src="_images/Modeling_272_0.png" />
</div>
</div>
<p>We’re actually unsure why a such small changes in the Poisson-distributed random variable expectations yields such large differences in the random variates for the same GSL RNG seed. For a substantial subset of elements, the random variates <em>are</em> equal, and that is not always where the difference in expectations is zero or relatively small. We consider this an open problem: please get in touch if you happen to read this and you have some insight you can share!</p>
<p>Here is the distribution of standardised variate residuals, for the realisation generated by this notebook, bearing in mind noise and that the Poisson distribution deparature from Gaussianity for lower expectations:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[112]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.figure(figsize=(8,8))
ax = plt.gcf().add_subplot(111)

variates = (yy - np.loadtxt(&#39;data/new_synthetic_realisation.dat&#39;, dtype=np.double))/np.sqrt(yy)

_ = ax.hist(variates.flatten(),
             bins=50,
             density=True,
             histtype=&#39;step&#39;,
             color=&#39;k&#39;,
             lw=1.0)

_x = np.linspace(-5.0,5.0,1000)
ax.plot(_x, np.exp(-0.5 * _x**2.0)/np.sqrt(2.0 * math.pi), &#39;k-.&#39;)

ax.set_xlabel(&#39;Count number standardised residuals&#39;)
ax.set_ylabel(&#39;Density&#39;)
XpsiPlot.veneer((0.25, 1.0), (0.01, 0.1), ax)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_275_0.png" src="_images/Modeling_275_0.png" />
</div>
</div>
<p>And there are no discernable correlations:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[113]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>XpsiPlot.plot_2d_pulse(pulse=variates,
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Standardised residuals&#39;,
                       cmap=cm.RdBu,
                       vmin=-np.max(np.fabs(variates)),
                       vmax=np.max(np.fabs(variates))
                      )
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_277_0.png" src="_images/Modeling_277_0.png" />
</div>
</div>
<p>If we switch now to a Steffen phase spline (that was used to generate the example data), the residuals disappear, as expected.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[114]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>xpsi.set_phase_interpolant(&#39;Steffen&#39;)
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[115]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>likelihood.synthesise(p, force=True, NICER=NICER_kwargs)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Exposure time: 932016.053222 [s]
Background normalisation: 1.96654684e-05
</pre></div></div>
</div>
<p>Note the small difference here in exposure time and background normalisation.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[116]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>z = np.loadtxt(&#39;data/new_synthetic_expected_hreadable.dat&#39;)
zz = np.zeros(data.counts.shape)
for i in range(xx.shape[0]):
    for j in range(xx.shape[1]):
        zz[i,j] = z[i*32 + j,-1]
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[117]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>_r = (zz-xx)/np.sqrt(zz)

XpsiPlot.plot_2d_pulse(pulse=_r,
                       x=_data.phases,
                       y=_data.channels,
                       rotations=1,
                       ylabel=&#39;Channel&#39;,
                       cbar_label=&#39;Standardised residuals&#39;,
                       cmap=cm.RdBu,
                       vmin=-np.max(np.fabs(_r)),
                       vmax=np.max(np.fabs(_r)))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/Modeling_283_0.png" src="_images/Modeling_283_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[118]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>diff = data.counts - np.loadtxt(&#39;data/new_synthetic_realisation.dat&#39;, dtype=np.double)
(diff != 0.0).any()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[118]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
False
</pre></div></div>
</div>
</section>
</section>
<section id="Summary">
<h2>Summary<a class="headerlink" href="#Summary" title="Link to this heading"></a></h2>
<p>In this notebook we constructed a model including a likelihood and prior objects. We also looked at the sampling interface, and concluded by synthesising the pre-prepared data set that was loaded at the beginning of the notebook.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="XPSI_101.html" class="btn btn-neutral float-left" title="X-PSI 101 - For Beginners" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Instrument_synergy.html" class="btn btn-neutral float-right" title="Instrument synergy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2025 the X-PSI Core Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>