from ._global_imports import *
from ._run import Run
from ._handle_hdf5 import *

try:
    from getdist.mcsamples import MCSamples
except ImportError:
    _warning('Cannot create a GetDist sample backend.')

try:
    from ._nestcheck_modifications import process_multinest_run
    from nestcheck.data_processing import process_polychord_run
except ImportError:
    _warning('Cannot use nestcheck sample backend.')

class NestedBackend(Run):
    """
    Container for nested samples generated by a single run, and backends
    for analysis of the run.

    The other keyword arguments are generic properties passed to the parent
    class, such as the identification (ID) string of the run.

    :param str root:
        The root filename of the sample file collection.

    :param str base_dir:
        The directly containing the sample file collection.

    :param bool use_nestcheck:
        Invoke :mod:`nestcheck` for nested sampling error analysis?

    :param callable transform:
        A function to transform the parameter vector to another space.

    """

    def __init__(self, root, base_dir, use_nestcheck, transform=None,
                 overwrite_transformed=False, **kwargs):
        filerootpath =_os.path.join(base_dir, root)
        # base_dir: ../../examples/examples_fast/Outputs/
        # root: ST_live_1000_eff_0.3_seed0

        # check whether to use .hdf5 files or .txt files 
        if _os.path.isfile(filerootpath+'.hdf5'):
            loader = load_group_from_hdf5
            filetype = ".hdf5"
        else:
            loader = _np.loadtxt
            filetype = ".txt"
            print("Change output files to .npy to speed up post-processing")

        if transform is not None:
            samples = loader(filerootpath + filetype) # .txt
            ndims = samples.shape[1] - 2
            temp = transform(samples[0,2:], old_API=True)
            ntransform = len(temp) - ndims

            _exists = _os.path.isfile(filerootpath+'_transformed'+filetype) # _transformed.txt
            if not _exists or overwrite_transformed:
                transformed = _np.zeros((samples.shape[0],
                                         samples.shape[1] + ntransform))
                transformed[:,:2] = samples[:,:2]
                for i in range(samples.shape[0]):
                    transformed[i,2:] = transform(samples[i,2:], old_API=True)
                if filetype == '.txt':
                    _np.savetxt(f'{filerootpath}_transformed{filetype}', transformed) # _transformed.txt
                else:
                    add_transform_group_to_hdf5(filerootpath, transformed, 
                                                paramnames, f'transformed-{ext}') ## Paramnames is the all param including derived ones e.g. ST.names 

        super(NestedBackend, self).__init__(filepath=f'{filerootpath}_transformed{filetype}',**kwargs) # _transformed.txt

        if getdist is not None:
            # getdist backend
            ## ADD hdf5 option here! 
            self._gd_bcknd = MCSamples(root=f'{filerootpath}_transformed',
                             settings=self.kde_settings,
                             sampler='nested',
                             names=self.names,
                             ranges=self.bounds,
                             labels=[self.labels[name] for name in self.names])
            self._gd_bcknd.readChains(getdist.chains.chainFiles(f'{filerootpath}_transformed'))

        self.use_nestcheck = use_nestcheck

        if self.use_nestcheck: # nestcheck backend
            if transform is not None:
                for ext in ['dead-birth', 'phys_live-birth']:
                    _exists = _os.path.isfile(filerootpath + ext + filetype)
                    if not _exists or overwrite_transformed:
                        if filetype == ".txt":
                            samples = loader(f'{filerootpath}_transformed-{ext}{filetype}')
                        else:
                            samples = load_group_from_hdf5(filerootpath + filetype, f'transformed_{ext}')
                        transformed = _np.zeros((samples.shape[0],
                                                 samples.shape[1] + ntransform))
                        transformed[:,ndims+ntransform:] = samples[:,ndims:]
                        for i in range(samples.shape[0]):
                            transformed[i,:ndims+ntransform] =\
                                                transform(samples[i,:ndims],
                                                          old_API=True)
                        _np.savetxt(f'{filerootpath}-{ext}{filetype}', transformed)
                         
            # assuming multinest for nestcheck if not specified   
            implementation = kwargs.get('implementation', 'multinest')
                
            if implementation == 'multinest':
                try:
                    self._nc_bcknd = process_multinest_run(f'{root}_transformed', base_dir, filetype)
                except FileNotFoundError:
                    self._nc_bcknd = process_multinest_run(f'{root}_transformed-', base_dir, filetype)
            elif implementation == 'polychord':
                self._nc_bcknd = process_polychord_run(f'{root}_transformed', base_dir, filetype)
            else:
                raise ValueError('Cannot process with nestcheck.')

    @property
    def getdist_backend(self):
        """ Get the :class:`getdist.mcsamples.MCSamples` instance. """
        return self._gd_bcknd

    @property
    def nestcheck_backend(self):
        """ Get the :mod:`nestcheck` backend for the nested samples. """
        return self._nc_bcknd

    @property
    def margeStats(self):
        """ Return the marginal statistics using :mod:`getdist`. """
        return self._mcsamples.getMargeStats()
